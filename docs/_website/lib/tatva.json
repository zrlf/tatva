{
  "name": "tatva",
  "path": "tatva",
  "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/__init__.py",
  "description": null,
  "docstring": [],
  "attributes": [],
  "modules": {
    "element": {
      "name": "element",
      "path": "tatva.element",
      "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/element/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "base": {
          "name": "base",
          "path": "tatva.element.base",
          "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/element/base.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "Element": {
              "name": "Element",
              "path": "tatva.element.base.Element",
              "description": "Base Module for all finite elements, compatible with JAX.",
              "parameters": [],
              "attributes": [
                {
                  "name": "quad_points",
                  "annotation": "equinox.AbstractClassVar[jaxtyping.Array]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "quad_weights",
                  "annotation": "equinox.AbstractClassVar[jaxtyping.Array]",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "shape_function": {
                  "name": "shape_function",
                  "path": "tatva.element.base.Element.shape_function",
                  "signature": "(self, xi) -> Array",
                  "description": "Returns the shape functions and their derivatives at a point.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@abstractmethod\ndef shape_function(self, xi: Array) -> Array:\n    \"\"\"Returns the shape functions and their derivatives at a point.\"\"\"\n    raise NotImplementedError"
                },
                "shape_function_derivative": {
                  "name": "shape_function_derivative",
                  "path": "tatva.element.base.Element.shape_function_derivative",
                  "signature": "(self, xi) -> Array",
                  "description": "Returns the derivative of the shape functions with respect to the local coordinates.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@abstractmethod\ndef shape_function_derivative(self, xi: Array) -> Array:\n    \"\"\"Returns the derivative of the shape functions with respect to the local coordinates.\"\"\"\n    raise NotImplementedError"
                },
                "get_jacobian": {
                  "name": "get_jacobian",
                  "path": "tatva.element.base.Element.get_jacobian",
                  "signature": "(self, xi, nodal_coords) -> tuple[Array, Array]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_coords",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_jacobian(self, xi: Array, nodal_coords: Array) -> tuple[Array, Array]:\n    dNdr = self.shape_function_derivative(xi)\n    J = dNdr @ nodal_coords\n    return J, jnp.linalg.det(J)"
                },
                "interpolate": {
                  "name": "interpolate",
                  "path": "tatva.element.base.Element.interpolate",
                  "signature": "(self, xi, nodal_values) -> Array",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_values",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def interpolate(self, xi: Array, nodal_values: Array) -> Array:\n    N = self.shape_function(xi)\n    return N @ nodal_values"
                },
                "gradient": {
                  "name": "gradient",
                  "path": "tatva.element.base.Element.gradient",
                  "signature": "(self, xi, nodal_values, nodal_coords) -> Array",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_values",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_coords",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def gradient(self, xi: Array, nodal_values: Array, nodal_coords: Array) -> Array:\n    dNdr = self.shape_function_derivative(xi)\n    J, _ = self.get_jacobian(xi, nodal_coords)\n    dNdX = jnp.linalg.inv(J) @ dNdr\n    return dNdX @ nodal_values"
                },
                "get_local_values": {
                  "name": "get_local_values",
                  "path": "tatva.element.base.Element.get_local_values",
                  "signature": "(self, xi, nodal_values, nodal_coords) -> tuple[Array, Array, Array]",
                  "description": "Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Local coordinates (shape: (n_dim,))."
                        }
                      ]
                    },
                    {
                      "name": "nodal_values",
                      "annotation": "jaxtyping.Array",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Values at the nodes of the element (shape: (n_nodes, n_values))."
                        }
                      ]
                    },
                    {
                      "name": "nodal_coords",
                      "annotation": "jaxtyping.Array",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Coordinates of the nodes of the element (shape: (n_nodes, n_dim))."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "tuple[jaxtyping.Array, jaxtyping.Array, jaxtyping.Array]",
                    "description": "A tuple containing:\n- Interpolated value at the local coordinates (shape: (n_values,)).\n- Gradient of the nodal values at the local coordinates (shape: (n_dim, n_values)).\n- Determinant of the Jacobian (scalar)."
                  },
                  "docstring": [],
                  "source": "def get_local_values(\n    self, xi: Array, nodal_values: Array, nodal_coords: Array\n) -> tuple[Array, Array, Array]:\n    \"\"\"Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.\n\n    Args:\n        xi: Local coordinates (shape: (n_dim,)).\n        nodal_values: Values at the nodes of the element (shape: (n_nodes, n_values)).\n        nodal_coords: Coordinates of the nodes of the element (shape: (n_nodes, n_dim)).\n\n    Returns:\n        A tuple containing:\n            - Interpolated value at the local coordinates (shape: (n_values,)).\n            - Gradient of the nodal values at the local coordinates (shape: (n_dim, n_values)).\n            - Determinant of the Jacobian (scalar).\n    \"\"\"\n    N = self.shape_function(xi)\n    dNdr = self.shape_function_derivative(xi)\n    J, detJ = self.get_jacobian(xi, nodal_coords)\n    dNdX = jnp.linalg.inv(J) @ dNdr\n    return N @ nodal_values, dNdX @ nodal_values, detJ"
                }
              },
              "source": "class Element(eqx.Module):\n    \"\"\"Base Module for all finite elements, compatible with JAX.\"\"\"\n\n    quad_points: AbstractClassVar[Array]\n    quad_weights: AbstractClassVar[Array]\n\n    @abstractmethod\n    def shape_function(self, xi: Array) -> Array:\n        \"\"\"Returns the shape functions and their derivatives at a point.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def shape_function_derivative(self, xi: Array) -> Array:\n        \"\"\"Returns the derivative of the shape functions with respect to the local coordinates.\"\"\"\n        raise NotImplementedError\n\n    def get_jacobian(self, xi: Array, nodal_coords: Array) -> tuple[Array, Array]:\n        dNdr = self.shape_function_derivative(xi)\n        J = dNdr @ nodal_coords\n        return J, jnp.linalg.det(J)\n\n    def interpolate(self, xi: Array, nodal_values: Array) -> Array:\n        N = self.shape_function(xi)\n        return N @ nodal_values\n\n    def gradient(self, xi: Array, nodal_values: Array, nodal_coords: Array) -> Array:\n        dNdr = self.shape_function_derivative(xi)\n        J, _ = self.get_jacobian(xi, nodal_coords)\n        dNdX = jnp.linalg.inv(J) @ dNdr\n        return dNdX @ nodal_values\n\n    def get_local_values(\n        self, xi: Array, nodal_values: Array, nodal_coords: Array\n    ) -> tuple[Array, Array, Array]:\n        \"\"\"Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.\n\n        Args:\n            xi: Local coordinates (shape: (n_dim,)).\n            nodal_values: Values at the nodes of the element (shape: (n_nodes, n_values)).\n            nodal_coords: Coordinates of the nodes of the element (shape: (n_nodes, n_dim)).\n\n        Returns:\n            A tuple containing:\n                - Interpolated value at the local coordinates (shape: (n_values,)).\n                - Gradient of the nodal values at the local coordinates (shape: (n_dim, n_values)).\n                - Determinant of the Jacobian (scalar).\n        \"\"\"\n        N = self.shape_function(xi)\n        dNdr = self.shape_function_derivative(xi)\n        J, detJ = self.get_jacobian(xi, nodal_coords)\n        dNdX = jnp.linalg.inv(J) @ dNdr\n        return N @ nodal_values, dNdX @ nodal_values, detJ",
              "inherited_members": {}
            },
            "Line2": {
              "name": "Line2",
              "path": "tatva.element.base.Line2",
              "description": "A 2-node linear interval element.",
              "parameters": [],
              "attributes": [
                {
                  "name": "quad_points",
                  "annotation": null,
                  "description": null,
                  "value": "jnp.array([[0.0]])"
                },
                {
                  "name": "quad_weights",
                  "annotation": null,
                  "description": null,
                  "value": "jnp.array([2.0])"
                }
              ],
              "docstring": [],
              "functions": {
                "shape_function": {
                  "name": "shape_function",
                  "path": "tatva.element.base.Line2.shape_function",
                  "signature": "(self, xi) -> Array",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function(self, xi: Array) -> Array:\n    xi_val = xi[0]\n    return jnp.array([0.5 * (1.0 - xi_val), 0.5 * (1.0 + xi_val)])"
                },
                "shape_function_derivative": {
                  "name": "shape_function_derivative",
                  "path": "tatva.element.base.Line2.shape_function_derivative",
                  "signature": "(self, xi) -> Array",
                  "description": "Returns the derivative of the shape functions with respect to the local coordinates.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function_derivative(self, xi: Array) -> Array:\n    \"\"\"Returns the derivative of the shape functions with respect to the local coordinates.\"\"\"\n    return jnp.array([-0.5, 0.5])"
                },
                "get_jacobian": {
                  "name": "get_jacobian",
                  "path": "tatva.element.base.Line2.get_jacobian",
                  "signature": "(self, xi, nodal_coords) -> tuple[Array, Array]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_coords",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_jacobian(self, xi: Array, nodal_coords: Array) -> tuple[Array, Array]:\n    _N, dNdr = self.shape_function(xi), self.shape_function_derivative(xi)\n    J = dNdr @ nodal_coords\n    t = jnp.asarray([J[0], J[1]]) / jnp.linalg.norm(J)\n    return jnp.dot(J, t), jnp.dot(J, t)"
                },
                "gradient": {
                  "name": "gradient",
                  "path": "tatva.element.base.Line2.gradient",
                  "signature": "(self, xi, nodal_values, nodal_coords) -> Array",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_values",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_coords",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def gradient(self, xi: Array, nodal_values: Array, nodal_coords: Array) -> Array:\n    _N, dNdr = self.shape_function(xi), self.shape_function_derivative(xi)\n    J, _ = self.get_jacobian(xi, nodal_coords)\n    dNdX = dNdr / J\n    return dNdX @ nodal_values"
                },
                "get_local_values": {
                  "name": "get_local_values",
                  "path": "tatva.element.base.Line2.get_local_values",
                  "signature": "(self, xi, nodal_values, nodal_coords) -> tuple[Array, Array, Array]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_values",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "nodal_coords",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_local_values(\n    self, xi: Array, nodal_values: Array, nodal_coords: Array\n) -> tuple[Array, Array, Array]:\n    N, dNdr = self.shape_function(xi), self.shape_function_derivative(xi)\n    J, detJ = self.get_jacobian(xi, nodal_coords)\n    dNdX = dNdr / J\n    return N @ nodal_values, dNdX @ nodal_values, detJ"
                }
              },
              "source": "class Line2(Element):\n    \"\"\"A 2-node linear interval element.\"\"\"\n\n    quad_points = jnp.array([[0.0]])\n    quad_weights = jnp.array([2.0])\n\n    def shape_function(self, xi: Array) -> Array:\n        xi_val = xi[0]\n        return jnp.array([0.5 * (1.0 - xi_val), 0.5 * (1.0 + xi_val)])\n\n    def shape_function_derivative(self, xi: Array) -> Array:\n        \"\"\"Returns the derivative of the shape functions with respect to the local coordinates.\"\"\"\n        return jnp.array([-0.5, 0.5])\n\n    def get_jacobian(self, xi: Array, nodal_coords: Array) -> tuple[Array, Array]:\n        _N, dNdr = self.shape_function(xi), self.shape_function_derivative(xi)\n        J = dNdr @ nodal_coords\n        t = jnp.asarray([J[0], J[1]]) / jnp.linalg.norm(J)\n        return jnp.dot(J, t), jnp.dot(J, t)\n\n    def gradient(self, xi: Array, nodal_values: Array, nodal_coords: Array) -> Array:\n        _N, dNdr = self.shape_function(xi), self.shape_function_derivative(xi)\n        J, _ = self.get_jacobian(xi, nodal_coords)\n        dNdX = dNdr / J\n        return dNdX @ nodal_values\n\n    def get_local_values(\n        self, xi: Array, nodal_values: Array, nodal_coords: Array\n    ) -> tuple[Array, Array, Array]:\n        N, dNdr = self.shape_function(xi), self.shape_function_derivative(xi)\n        J, detJ = self.get_jacobian(xi, nodal_coords)\n        dNdX = dNdr / J\n        return N @ nodal_values, dNdX @ nodal_values, detJ",
              "inherited_members": {
                "tatva.element.base.Element": [
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.interpolate"
                  }
                ]
              }
            },
            "Tri3": {
              "name": "Tri3",
              "path": "tatva.element.base.Tri3",
              "description": "A 3-node linear triangular element.",
              "parameters": [],
              "attributes": [
                {
                  "name": "quad_points",
                  "annotation": null,
                  "description": null,
                  "value": "jnp.array([[1.0 / 3, 1.0 / 3]])"
                },
                {
                  "name": "quad_weights",
                  "annotation": null,
                  "description": null,
                  "value": "jnp.array([1.0 / 2])"
                }
              ],
              "docstring": [],
              "functions": {
                "shape_function": {
                  "name": "shape_function",
                  "path": "tatva.element.base.Tri3.shape_function",
                  "signature": "(self, xi) -> Array",
                  "description": "Returns the shape functions evaluated at the local coordinates (xi, eta).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function(self, xi: Array) -> Array:\n    \"\"\"Returns the shape functions evaluated at the local coordinates (xi, eta).\"\"\"\n    xi1, xi2 = xi\n    return jnp.array([1.0 - xi1 - xi2, xi1, xi2])"
                },
                "shape_function_derivative": {
                  "name": "shape_function_derivative",
                  "path": "tatva.element.base.Tri3.shape_function_derivative",
                  "signature": "(self, *_args, **_kwargs) -> Array",
                  "description": "Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "_kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function_derivative(self, *_args, **_kwargs) -> Array:\n    \"\"\"Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).\"\"\"\n    # shape (n_q, 2, 3)\n    return jnp.array([[-1.0, -1.0], [1.0, 0.0], [0.0, 1.0]]).T"
                }
              },
              "source": "class Tri3(Element):\n    \"\"\"A 3-node linear triangular element.\"\"\"\n\n    quad_points = jnp.array([[1.0 / 3, 1.0 / 3]])\n    quad_weights = jnp.array([1.0 / 2])\n\n    def shape_function(self, xi: Array) -> Array:\n        \"\"\"Returns the shape functions evaluated at the local coordinates (xi, eta).\"\"\"\n        xi1, xi2 = xi\n        return jnp.array([1.0 - xi1 - xi2, xi1, xi2])\n\n    def shape_function_derivative(self, *_args, **_kwargs) -> Array:\n        \"\"\"Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).\"\"\"\n        # shape (n_q, 2, 3)\n        return jnp.array([[-1.0, -1.0], [1.0, 0.0], [0.0, 1.0]]).T",
              "inherited_members": {
                "tatva.element.base.Element": [
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.get_jacobian"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.interpolate"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.gradient"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.get_local_values"
                  }
                ]
              }
            },
            "Quad4": {
              "name": "Quad4",
              "path": "tatva.element.base.Quad4",
              "description": "A 4-node bilinear quadrilateral element.",
              "parameters": [],
              "attributes": [
                {
                  "name": "quad_points",
                  "annotation": null,
                  "description": null,
                  "value": "_quad4_qp"
                },
                {
                  "name": "quad_weights",
                  "annotation": null,
                  "description": null,
                  "value": "_quad4_w"
                }
              ],
              "docstring": [],
              "functions": {
                "shape_function": {
                  "name": "shape_function",
                  "path": "tatva.element.base.Quad4.shape_function",
                  "signature": "(self, xi) -> Array",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function(self, xi: Array) -> Array:\n    r, s = xi\n    return 0.25 * jnp.array(\n        [(1 - r) * (1 - s), (1 + r) * (1 - s), (1 + r) * (1 + s), (1 - r) * (1 + s)]\n    )"
                },
                "shape_function_derivative": {
                  "name": "shape_function_derivative",
                  "path": "tatva.element.base.Quad4.shape_function_derivative",
                  "signature": "(self, xi) -> Array",
                  "description": "Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function_derivative(self, xi: Array) -> Array:\n    \"\"\"Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).\"\"\"\n    r, s = xi\n    return (\n        0.25\n        * jnp.array(\n            [\n                [-(1 - s), -(1 - r)],\n                [(1 - s), -(1 + r)],\n                [(1 + s), (1 + r)],\n                [-(1 + s), (1 - r)],\n            ]\n        ).T\n    )"
                }
              },
              "source": "class Quad4(Element):\n    \"\"\"A 4-node bilinear quadrilateral element.\"\"\"\n\n    quad_points = _quad4_qp\n    quad_weights = _quad4_w\n\n    def shape_function(self, xi: Array) -> Array:\n        r, s = xi\n        return 0.25 * jnp.array(\n            [(1 - r) * (1 - s), (1 + r) * (1 - s), (1 + r) * (1 + s), (1 - r) * (1 + s)]\n        )\n\n    def shape_function_derivative(self, xi: Array) -> Array:\n        \"\"\"Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).\"\"\"\n        r, s = xi\n        return (\n            0.25\n            * jnp.array(\n                [\n                    [-(1 - s), -(1 - r)],\n                    [(1 - s), -(1 + r)],\n                    [(1 + s), (1 + r)],\n                    [-(1 + s), (1 - r)],\n                ]\n            ).T\n        )",
              "inherited_members": {
                "tatva.element.base.Element": [
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.get_jacobian"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.interpolate"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.gradient"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.get_local_values"
                  }
                ]
              }
            },
            "Tetrahedron4": {
              "name": "Tetrahedron4",
              "path": "tatva.element.base.Tetrahedron4",
              "description": "A 4-node linear tetrahedral element.",
              "parameters": [],
              "attributes": [
                {
                  "name": "quad_points",
                  "annotation": null,
                  "description": null,
                  "value": "jnp.array([[1.0 / 4, 1.0 / 4, 1.0 / 4]])"
                },
                {
                  "name": "quad_weights",
                  "annotation": null,
                  "description": null,
                  "value": "jnp.array([1.0 / 6])"
                }
              ],
              "docstring": [],
              "functions": {
                "shape_function": {
                  "name": "shape_function",
                  "path": "tatva.element.base.Tetrahedron4.shape_function",
                  "signature": "(self, xi) -> Array",
                  "description": "Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function(self, xi: Array) -> Array:\n    \"\"\"Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).\"\"\"\n    xi, eta, zeta = xi\n    return jnp.array([1.0 - xi - eta - zeta, xi, eta, zeta])"
                },
                "shape_function_derivative": {
                  "name": "shape_function_derivative",
                  "path": "tatva.element.base.Tetrahedron4.shape_function_derivative",
                  "signature": "(self, *_args, **_kwargs) -> Array",
                  "description": "Returns the derivative of the shape functions with respect to the local coordinates (xi, eta, zeta).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "_kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function_derivative(self, *_args, **_kwargs) -> Array:\n    \"\"\"Returns the derivative of the shape functions with respect to the local coordinates (xi, eta, zeta).\"\"\"\n    # shape (n_q, 3, 4)\n    return jnp.array(\n        [[-1.0, -1.0, -1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    ).T"
                }
              },
              "source": "class Tetrahedron4(Element):\n    \"\"\"A 4-node linear tetrahedral element.\"\"\"\n\n    quad_points = jnp.array([[1.0 / 4, 1.0 / 4, 1.0 / 4]])\n    quad_weights = jnp.array([1.0 / 6])\n\n    def shape_function(self, xi: Array) -> Array:\n        \"\"\"Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).\"\"\"\n        xi, eta, zeta = xi\n        return jnp.array([1.0 - xi - eta - zeta, xi, eta, zeta])\n\n    def shape_function_derivative(self, *_args, **_kwargs) -> Array:\n        \"\"\"Returns the derivative of the shape functions with respect to the local coordinates (xi, eta, zeta).\"\"\"\n        # shape (n_q, 3, 4)\n        return jnp.array(\n            [[-1.0, -1.0, -1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n        ).T",
              "inherited_members": {
                "tatva.element.base.Element": [
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.get_jacobian"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.interpolate"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.gradient"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.get_local_values"
                  }
                ]
              }
            },
            "Hexahedron8": {
              "name": "Hexahedron8",
              "path": "tatva.element.base.Hexahedron8",
              "description": "A 8-node linear hexahedral element.",
              "parameters": [],
              "attributes": [
                {
                  "name": "quad_points",
                  "annotation": null,
                  "description": null,
                  "value": "_hex8_qp"
                },
                {
                  "name": "quad_weights",
                  "annotation": null,
                  "description": null,
                  "value": "_hex8_w"
                }
              ],
              "docstring": [],
              "functions": {
                "shape_function": {
                  "name": "shape_function",
                  "path": "tatva.element.base.Hexahedron8.shape_function",
                  "signature": "(self, xi) -> Array",
                  "description": "Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function(self, xi: Array) -> Array:\n    \"\"\"Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).\"\"\"\n    xi, eta, zeta = xi\n    return (1 / 8) * jnp.array(\n        [\n            (1 - xi) * (1 - eta) * (1 - zeta),\n            (1 + xi) * (1 - eta) * (1 - zeta),\n            (1 + xi) * (1 + eta) * (1 - zeta),\n            (1 - xi) * (1 + eta) * (1 - zeta),\n            (1 - xi) * (1 - eta) * (1 + zeta),\n            (1 + xi) * (1 - eta) * (1 + zeta),\n            (1 + xi) * (1 + eta) * (1 + zeta),\n            (1 - xi) * (1 + eta) * (1 + zeta),\n        ]\n    )"
                },
                "shape_function_derivative": {
                  "name": "shape_function_derivative",
                  "path": "tatva.element.base.Hexahedron8.shape_function_derivative",
                  "signature": "(self, xi) -> Array",
                  "description": "Returns the derivative of the shape functions with respect to the local coordinates (xi, eta, zeta).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "xi",
                      "annotation": "jaxtyping.Array",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def shape_function_derivative(self, xi: Array) -> Array:\n    \"\"\"Returns the derivative of the shape functions with respect to the local coordinates (xi, eta, zeta).\"\"\"\n    # shape (n_q, 3, 8)\n    xi, eta, zeta = xi\n    return (1 / 8) * jnp.array(\n        [\n            [\n                -(1 - eta) * (1 - zeta),\n                -(1 - xi) * (1 - zeta),\n                -(1 - xi) * (1 - eta),\n            ],\n            [(1 - eta) * (1 - zeta), -(1 + xi) * (1 - zeta), -(1 + xi) * (1 - eta)],\n            [(1 + eta) * (1 - zeta), (1 + xi) * (1 - zeta), -(1 + xi) * (1 + eta)],\n            [-(1 + eta) * (1 - zeta), (1 - xi) * (1 - zeta), -(1 - xi) * (1 + eta)],\n            [-(1 - eta) * (1 + zeta), -(1 - xi) * (1 + zeta), (1 - xi) * (1 - eta)],\n            [(1 - eta) * (1 + zeta), -(1 + xi) * (1 + zeta), (1 + xi) * (1 - eta)],\n            [(1 + eta) * (1 + zeta), (1 + xi) * (1 + zeta), (1 + xi) * (1 + eta)],\n            [-(1 + eta) * (1 + zeta), (1 - xi) * (1 + zeta), (1 - xi) * (1 + eta)],\n        ]\n    )"
                }
              },
              "source": "class Hexahedron8(Element):\n    \"\"\"A 8-node linear hexahedral element.\"\"\"\n\n    quad_points = _hex8_qp\n    quad_weights = _hex8_w\n\n    def shape_function(self, xi: Array) -> Array:\n        \"\"\"Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).\"\"\"\n        xi, eta, zeta = xi\n        return (1 / 8) * jnp.array(\n            [\n                (1 - xi) * (1 - eta) * (1 - zeta),\n                (1 + xi) * (1 - eta) * (1 - zeta),\n                (1 + xi) * (1 + eta) * (1 - zeta),\n                (1 - xi) * (1 + eta) * (1 - zeta),\n                (1 - xi) * (1 - eta) * (1 + zeta),\n                (1 + xi) * (1 - eta) * (1 + zeta),\n                (1 + xi) * (1 + eta) * (1 + zeta),\n                (1 - xi) * (1 + eta) * (1 + zeta),\n            ]\n        )\n\n    def shape_function_derivative(self, xi: Array) -> Array:\n        \"\"\"Returns the derivative of the shape functions with respect to the local coordinates (xi, eta, zeta).\"\"\"\n        # shape (n_q, 3, 8)\n        xi, eta, zeta = xi\n        return (1 / 8) * jnp.array(\n            [\n                [\n                    -(1 - eta) * (1 - zeta),\n                    -(1 - xi) * (1 - zeta),\n                    -(1 - xi) * (1 - eta),\n                ],\n                [(1 - eta) * (1 - zeta), -(1 + xi) * (1 - zeta), -(1 + xi) * (1 - eta)],\n                [(1 + eta) * (1 - zeta), (1 + xi) * (1 - zeta), -(1 + xi) * (1 + eta)],\n                [-(1 + eta) * (1 - zeta), (1 - xi) * (1 - zeta), -(1 - xi) * (1 + eta)],\n                [-(1 - eta) * (1 + zeta), -(1 - xi) * (1 + zeta), (1 - xi) * (1 - eta)],\n                [(1 - eta) * (1 + zeta), -(1 + xi) * (1 + zeta), (1 + xi) * (1 - eta)],\n                [(1 + eta) * (1 + zeta), (1 + xi) * (1 + zeta), (1 + xi) * (1 + eta)],\n                [-(1 + eta) * (1 + zeta), (1 - xi) * (1 + zeta), (1 - xi) * (1 + eta)],\n            ]\n        )",
              "inherited_members": {
                "tatva.element.base.Element": [
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.get_jacobian"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.interpolate"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.gradient"
                  },
                  {
                    "kind": "function",
                    "path": "tatva.element.base.Element.get_local_values"
                  }
                ]
              }
            }
          },
          "functions": {
            "_get_quad4_quadrature": {
              "name": "_get_quad4_quadrature",
              "path": "tatva.element.base._get_quad4_quadrature",
              "signature": "() -> tuple[Array, Array]",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _get_quad4_quadrature() -> tuple[Array, Array]:\n    xi_vals = jnp.array([-1.0 / jnp.sqrt(3), 1.0 / jnp.sqrt(3)])\n    w_vals = jnp.array([1.0, 1.0])\n    quad_points = jnp.stack(jnp.meshgrid(xi_vals, xi_vals), axis=-1).reshape(-1, 2)\n    weights = jnp.kron(w_vals, w_vals)\n    return quad_points, weights"
            },
            "_get_hex8_quadrature": {
              "name": "_get_hex8_quadrature",
              "path": "tatva.element.base._get_hex8_quadrature",
              "signature": "() -> tuple[Array, Array]",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _get_hex8_quadrature() -> tuple[Array, Array]:\n    xi_vals = jnp.array([-1.0 / jnp.sqrt(3), 1.0 / jnp.sqrt(3)])\n    quad_points = jnp.stack(jnp.meshgrid(xi_vals, xi_vals, xi_vals), axis=-1).reshape(\n        -1, 3\n    )\n    weights = jnp.full(quad_points.shape[0], fill_value=1.0)\n    return quad_points, weights"
            }
          }
        }
      },
      "classes": {},
      "functions": {}
    },
    "operator": {
      "name": "operator",
      "path": "tatva.operator",
      "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/operator.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "P",
          "annotation": null,
          "description": null,
          "value": "ParamSpec('P')"
        },
        {
          "name": "RT",
          "annotation": null,
          "description": null,
          "value": "TypeVar('RT', bound=(jax.Array | tuple), covariant=True)"
        },
        {
          "name": "ElementT",
          "annotation": null,
          "description": null,
          "value": "TypeVar('ElementT', bound=Element)"
        },
        {
          "name": "Numeric",
          "annotation": "typing.TypeAlias",
          "description": null,
          "value": "float | int | jax.numpy.jax.numpy.number"
        },
        {
          "name": "MappableOverElements",
          "annotation": "typing.TypeAlias",
          "description": null,
          "value": "typing.Callable[tatva.operator.P, tatva.operator.RT]"
        }
      ],
      "modules": {},
      "classes": {
        "MappableOverElementsAndQuads": {
          "name": "MappableOverElementsAndQuads",
          "path": "tatva.operator.MappableOverElementsAndQuads",
          "description": "Internal protocol for functions that are mapped over elements using\n`Operator.map`.",
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__call__": {
              "name": "__call__",
              "path": "tatva.operator.MappableOverElementsAndQuads.__call__",
              "signature": "(xi, *el_values, **el_kwargs) -> RT",
              "description": null,
              "parameters": [
                {
                  "name": "xi",
                  "annotation": "jax.jax.Array",
                  "description": null,
                  "value": null
                },
                {
                  "name": "el_values",
                  "annotation": "tatva.operator.P.tatva.operator.P.args",
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "el_kwargs",
                  "annotation": "tatva.operator.P.tatva.operator.P.kwargs",
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef __call__(\n    xi: jax.Array,\n    *el_values: P.args,\n    **el_kwargs: P.kwargs,\n) -> RT: ..."
            }
          },
          "source": "class MappableOverElementsAndQuads(Protocol[P, RT]):\n    \"\"\"Internal protocol for functions that are mapped over elements using\n    `Operator.map`.\"\"\"\n\n    @staticmethod\n    def __call__(\n        xi: jax.Array,\n        *el_values: P.args,\n        **el_kwargs: P.kwargs,\n    ) -> RT: ...",
          "inherited_members": {}
        },
        "MappedCallable": {
          "name": "MappedCallable",
          "path": "tatva.operator.MappedCallable",
          "description": null,
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__call__": {
              "name": "__call__",
              "path": "tatva.operator.MappedCallable.__call__",
              "signature": "(*args, **kwargs) -> RT",
              "description": null,
              "parameters": [
                {
                  "name": "args",
                  "annotation": "tatva.operator.P.tatva.operator.P.args",
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": "tatva.operator.P.tatva.operator.P.kwargs",
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef __call__(\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -> RT: ..."
            }
          },
          "source": "class MappedCallable(Protocol[P, RT]):\n    @staticmethod\n    def __call__(\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> RT: ...",
          "inherited_members": {}
        },
        "Operator": {
          "name": "Operator",
          "path": "tatva.operator.Operator",
          "description": "A class that provides an Operator for finite element method (FEM) assembly.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "mesh",
              "annotation": "tatva.mesh.Mesh",
              "description": [
                {
                  "kind": "text",
                  "value": "The mesh containing the elements and nodes."
                }
              ]
            },
            {
              "name": "element",
              "annotation": "tatva.element.Element",
              "description": [
                {
                  "kind": "text",
                  "value": "The element type used for the finite element method."
                }
              ]
            }
          ],
          "attributes": [
            {
              "name": "mesh",
              "annotation": "tatva.mesh.Mesh",
              "description": null,
              "value": "tatva.operator.Operator(mesh)"
            },
            {
              "name": "element",
              "annotation": "tatva.operator.ElementT",
              "description": null,
              "value": "tatva.operator.Operator(element)"
            },
            {
              "name": "det_J_elements_weights",
              "annotation": "jax.Array",
              "description": null,
              "value": "jnp.einsum('eq,q->eq', det_J_elements, self.element.quad_weights)"
            }
          ],
          "docstring": [
            {
              "kind": "text",
              "value": "Provides several operators for evaluating and integrating functions over the mesh,\nsuch as `integrate`, `eval`, and `grad`. These operators can be used to compute\nintegrals, evaluate functions at quadrature points, and compute gradients of\nfunctions at quadrature points."
            },
            {
              "kind": "admonition",
              "value": {
                "annotation": "example",
                "description": ">>> from tatva import Mesh, Tri3, Operator\n>>> mesh = Mesh.unit_square(10, 10)  # Create a mesh\n>>> element = Tri3()  # Define an element type\n>>> operator = Operator(mesh, element)\n>>> nodal_values = jnp.array(...)  # Nodal values at the mesh nodes\n>>> energy = operator.integrate(energy_density)(nodal_values)"
              },
              "title": "Example"
            }
          ],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "tatva.operator.Operator.__init__",
              "signature": "(self, mesh, element)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "mesh",
                  "annotation": "tatva.mesh.Mesh",
                  "description": null,
                  "value": null
                },
                {
                  "name": "element",
                  "annotation": "tatva.element.Element",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, mesh: Mesh, element: Element):\n    self.mesh = mesh\n    self.element = element\n\n    def _get_det_J(xi: jax.Array, el_nodal_coords: jax.Array) -> jax.Array:\n        \"\"\"Calls the function element.get_jacobian and returns the second output.\"\"\"\n        return self.element.get_jacobian(xi, el_nodal_coords)[1]\n\n    det_J_elements = self.map(_get_det_J)(self.mesh.coords)\n    self.det_J_elements_weights = jnp.einsum(\n        \"eq,q->eq\", det_J_elements, self.element.quad_weights\n    )"
            },
            "__check_init__": {
              "name": "__check_init__",
              "path": "tatva.operator.Operator.__check_init__",
              "signature": "(self) -> None",
              "description": "Validates the mesh and element compatibility. Does a series of checks to ensure\nthat the mesh and element are useable together.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [
                {
                  "kind": "raises",
                  "value": [
                    {
                      "annotation": "ValueError",
                      "description": "If the mesh or element are not compatible."
                    },
                    {
                      "annotation": "TypeError",
                      "description": "If the mesh element connectivity is not of integer type."
                    }
                  ]
                }
              ],
              "source": "def __check_init__(self) -> None:\n    \"\"\"Validates the mesh and element compatibility. Does a series of checks to ensure\n    that the mesh and element are useable together.\n\n    Raises:\n        ValueError: If the mesh or element are not compatible.\n        TypeError: If the mesh element connectivity is not of integer type.\n    \"\"\"\n    coords = self.mesh.coords\n    elements = self.mesh.elements\n    quad_points = self.element.quad_points\n\n    if coords.ndim != 2:\n        raise ValueError(\n            \"Mesh coordinates must be a 2D array shaped (n_nodes, n_dim).\"\n        )\n    if coords.shape[0] == 0:\n        raise ValueError(\"Mesh must contain at least one node.\")\n\n    if elements.ndim != 2:\n        raise ValueError(\n            \"Mesh elements must be a 2D array shaped (n_elements, n_nodes_per_element).\"\n        )\n    if elements.shape[0] == 0:\n        raise ValueError(\"Mesh must contain at least one element.\")\n    if not jnp.issubdtype(elements.dtype, jnp.integer):\n        raise TypeError(\"Mesh element connectivity must contain integer indices.\")\n\n    if quad_points.ndim != 2 or quad_points.shape[0] == 0:\n        raise ValueError(\n            \"Element must define at least one quadrature point in an (n_q, n_dim) array.\"\n        )\n\n    local_dim = quad_points.shape[1]\n    global_dim = coords.shape[1]\n    if local_dim > 1 and local_dim != global_dim:\n        raise ValueError(\n            f\"Element {self.element.__class__.__name__} expects {local_dim}D coordinates but mesh provides {global_dim}D nodes.\"\n        )\n    if local_dim == 0:\n        raise ValueError(\"Element must have a positive number of local dimensions.\")\n\n    n_nodes_per_element = elements.shape[1]\n    shape_fn = np.asarray(self.element.shape_function(self.element.quad_points[0]))\n    if shape_fn.ndim != 1:\n        raise ValueError(\n            \"Element shape function must return a 1D array of nodal weights.\"\n        )\n    if shape_fn.shape[0] != n_nodes_per_element:\n        raise ValueError(\n            f\"Mesh connectivity lists {n_nodes_per_element} nodes per element but {self.element.__class__.__name__} expects {shape_fn.shape[0]}.\"\n        )\n\n    flat_elements = elements.ravel()\n    if flat_elements.min() < 0:\n        raise ValueError(\n            \"Mesh element connectivity contains negative node indices.\"\n        )\n    if flat_elements.max() >= coords.shape[0]:\n        raise ValueError(\n            \"Mesh element connectivity references nodes outside the mesh coordinates array.\"\n        )"
            },
            "_vmap_over_elements_and_quads": {
              "name": "_vmap_over_elements_and_quads",
              "path": "tatva.operator.Operator._vmap_over_elements_and_quads",
              "signature": "(self, nodal_values, func) -> jax.Array",
              "description": "Helper function. Maps a function over the elements and quadrature points of the\nmesh.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "nodal_values",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The nodal values at the element's nodes (shape: (n_nodes, n_values))"
                    }
                  ]
                },
                {
                  "name": "func",
                  "annotation": "tatva.operator.MappableOverElementsAndQuads",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to map over the elements and quadrature points."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.jax.Array",
                "description": "A jax.Array with the results of the function applied at each quadrature point"
              },
              "docstring": [],
              "source": "def _vmap_over_elements_and_quads(\n    self, nodal_values: jax.Array, func: MappableOverElementsAndQuads\n) -> jax.Array:\n    \"\"\"Helper function. Maps a function over the elements and quadrature points of the\n    mesh.\n\n    Args:\n        nodal_values: The nodal values at the element's nodes (shape: (n_nodes, n_values))\n        func: The function to map over the elements and quadrature points.\n\n    Returns:\n        A jax.Array with the results of the function applied at each quadrature point\n        of each element (shape: (n_elements, n_quad_points, n_values)).\n    \"\"\"\n\n    def _at_each_element(\n        el_nodal_values: jax.Array, el_nodal_coords: jax.Array\n    ) -> jax.Array:\n        return eqx.filter_vmap(\n            partial(\n                func,\n                el_nodal_values=el_nodal_values,\n                el_nodal_coords=el_nodal_coords,\n            )\n        )(self.element.quad_points)\n\n    return eqx.filter_vmap(\n        _at_each_element,\n        in_axes=(0, 0),\n    )(nodal_values[self.mesh.elements], self.mesh.coords[self.mesh.elements])"
            },
            "map": {
              "name": "map",
              "path": "tatva.operator.Operator.map",
              "signature": "(self, func, *, element_quantity=()) -> MappedCallable[P, RT]",
              "description": "Maps a function over the elements and quad points of the mesh.\n\nReturns a function that takes values at nodal points (globally) and returns the\nvmapped result over the elements and quad points.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "func",
                  "annotation": "tatva.operator.MappableOverElementsAndQuads[tatva.operator.P, tatva.operator.RT]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to map over the elements and quadrature points."
                    }
                  ]
                },
                {
                  "name": "element_quantity",
                  "annotation": "collections.abc.Sequence[int]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Indices of the arguments of `func` that are quantities\ndefined per element. The rest of the arguments are assumed to be defined\nat nodal points."
                    }
                  ],
                  "value": "()"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def map(\n    self,\n    func: MappableOverElementsAndQuads[P, RT],\n    *,\n    element_quantity: Sequence[int] = (),\n) -> MappedCallable[P, RT]:\n    \"\"\"Maps a function over the elements and quad points of the mesh.\n\n    Returns a function that takes values at nodal points (globally) and returns the\n    vmapped result over the elements and quad points.\n\n    Args:\n        func: The function to map over the elements and quadrature points.\n        element_quantity: Indices of the arguments of `func` that are quantities\n            defined per element. The rest of the arguments are assumed to be defined\n            at nodal points.\n    \"\"\"\n\n    def _mapped(*values: P.args, **kwargs: P.kwargs) -> RT:\n        # values should be arrays!\n        _values = cast(tuple[jax.Array, ...], values)\n\n        def _at_each_element(*el_values) -> jax.Array:\n            return eqx.filter_vmap(\n                lambda xi: func(xi, *el_values, **kwargs),\n            )(self.element.quad_points)\n\n        return eqx.filter_vmap(\n            _at_each_element,\n            in_axes=(0,) * len(values),\n        )(\n            *(\n                v[self.mesh.elements] if i not in element_quantity else v\n                for i, v in enumerate(_values)\n            )\n        )\n\n    return _mapped"
            },
            "map_over_elements": {
              "name": "map_over_elements",
              "path": "tatva.operator.Operator.map_over_elements",
              "signature": "(self, func, *, element_quantity=()) -> MappedCallable[P, RT]",
              "description": "Maps a function over the elements of the mesh.\n\nReturns a function that takes values at nodal points (globally) and returns the\nvmapped result over the elements.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "func",
                  "annotation": "tatva.operator.MappableOverElements[tatva.operator.P, tatva.operator.RT]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to map over the elements."
                    }
                  ]
                },
                {
                  "name": "element_quantity",
                  "annotation": "collections.abc.Sequence[int]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Indices of the arguments of `func` that are quantities\ndefined per element. The rest of the arguments are assumed to be defined\nat nodal points."
                    }
                  ],
                  "value": "()"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def map_over_elements(\n    self,\n    func: MappableOverElements[P, RT],\n    *,\n    element_quantity: Sequence[int] = (),\n) -> MappedCallable[P, RT]:\n    \"\"\"Maps a function over the elements of the mesh.\n\n    Returns a function that takes values at nodal points (globally) and returns the\n    vmapped result over the elements.\n\n    Args:\n        func: The function to map over the elements.\n        element_quantity: Indices of the arguments of `func` that are quantities\n            defined per element. The rest of the arguments are assumed to be defined\n            at nodal points.\n    \"\"\"\n\n    def _mapped(*values: P.args, **kwargs: P.kwargs) -> RT:\n        # values should be arrays!\n        _values = cast(tuple[jax.Array, ...], values)\n\n        def _at_each_element(*el_values) -> RT:\n            return func(*el_values, **kwargs)\n\n        return eqx.filter_vmap(\n            _at_each_element,\n            in_axes=(0,) * len(values),\n        )(\n            *(\n                v[self.mesh.elements] if i not in element_quantity else v\n                for i, v in enumerate(_values)\n            )\n        )\n\n    return _mapped"
            },
            "integrate": {
              "name": "integrate",
              "path": "tatva.operator.Operator.integrate",
              "signature": "(self, arg) -> jax.Array",
              "description": "Integrate a nodal_array, quad_array, or numeric value over the mesh.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "arg",
                  "annotation": "jax.jax.Array | tatva.operator.Numeric",
                  "description": [
                    {
                      "kind": "text",
                      "value": "An array of nodal values (shape: (n_nodes, n_values)), an array of\nquadrature values (shape: (n_elements, n_quad_points, n_values)), or a\nnumeric value (float or int)."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.jax.Array",
                "description": "The integral of the nodal values or quadrature values over the mesh."
              },
              "docstring": [],
              "source": "def integrate(self, arg: jax.Array | Numeric) -> jax.Array:\n    \"\"\"Integrate a nodal_array, quad_array, or numeric value over the mesh.\n\n    Args:\n        arg: An array of nodal values (shape: (n_nodes, n_values)), an array of\n            quadrature values (shape: (n_elements, n_quad_points, n_values)), or a\n            numeric value (float or int).\n\n    Returns:\n        The integral of the nodal values or quadrature values over the mesh.\n    \"\"\"\n    res = self.integrate_per_element(arg)\n    return jnp.sum(res, axis=(0,))  # Sum over elements and quadrature points"
            },
            "integrate_per_element": {
              "name": "integrate_per_element",
              "path": "tatva.operator.Operator.integrate_per_element",
              "signature": "(self, arg) -> jax.Array",
              "description": "Integrate a nodal_array, quad_array, or numeric value over the mesh. Returning the\nintegral per element.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "arg",
                  "annotation": "jax.jax.Array | tatva.operator.Numeric",
                  "description": [
                    {
                      "kind": "text",
                      "value": "An array of nodal values (shape: (n_nodes, n_values)), an array of\nquadrature values (shape: (n_elements, n_quad_points, n_values)), or a\nnumeric value (float or int)."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.jax.Array",
                "description": "A `jax.Array` where each element contains the integral of the values in the"
              },
              "docstring": [],
              "source": "def integrate_per_element(self, arg: jax.Array | Numeric) -> jax.Array:\n    \"\"\"Integrate a nodal_array, quad_array, or numeric value over the mesh. Returning the\n    integral per element.\n\n    Args:\n        arg: An array of nodal values (shape: (n_nodes, n_values)), an array of\n            quadrature values (shape: (n_elements, n_quad_points, n_values)), or a\n            numeric value (float or int).\n\n    Returns:\n        A `jax.Array` where each element contains the integral of the values in the\n        element (shape: (n_elements, n_values)).\n    \"\"\"\n    if isinstance(arg, Numeric):\n        res = self._integrate_quad_array(self.eval(jnp.array([arg])))\n    elif arg.shape[0] == self.mesh.elements.shape[0]:  # element field\n        res = self._integrate_quad_array(arg)\n    else:  # nodal field\n        field_at_quads = self.eval(arg)\n        res = self._integrate_quad_array(field_at_quads)\n\n    return res"
            },
            "_integrate_quad_array": {
              "name": "_integrate_quad_array",
              "path": "tatva.operator.Operator._integrate_quad_array",
              "signature": "(self, quad_values) -> jax.Array",
              "description": "Integrates a given array of values at quadrature points over the mesh.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "quad_values",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The values at the quadrature points\n(shape: (n_elements, n_quad_points, n_values))"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.jax.Array",
                "description": "A `jax.Array` where each element contains the integral of the values in the"
              },
              "docstring": [],
              "source": "def _integrate_quad_array(self, quad_values: jax.Array) -> jax.Array:\n    \"\"\"Integrates a given array of values at quadrature points over the mesh.\n\n    Args:\n        quad_values: The values at the quadrature points\n            (shape: (n_elements, n_quad_points, n_values))\n\n    Returns:\n        A `jax.Array` where each element contains the integral of the values in the\n        element (shape: (n_elements, n_values)).\n    \"\"\"\n\n    return jnp.einsum(\"eq...,eq->e...\", quad_values, self.det_J_elements_weights)"
            },
            "eval": {
              "name": "eval",
              "path": "tatva.operator.Operator.eval",
              "signature": "(self, nodal_values) -> jax.Array",
              "description": "Evaluates the nodal values at the quadrature points.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "nodal_values",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The nodal values at the element's nodes (shape: (n_nodes, n_values))"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.jax.Array",
                "description": "A `jax.Array` with the values of the nodal values at each quadrature point of"
              },
              "docstring": [],
              "source": "def eval(self, nodal_values: jax.Array) -> jax.Array:\n    \"\"\"Evaluates the nodal values at the quadrature points.\n\n    Args:\n        nodal_values: The nodal values at the element's nodes (shape: (n_nodes, n_values))\n\n    Returns:\n        A `jax.Array` with the values of the nodal values at each quadrature point of\n        each element (shape: (n_elements, n_quad_points, n_values)).\n    \"\"\"\n\n    def _eval_quad(\n        xi: jax.Array, el_nodal_values: jax.Array, el_nodal_coords: jax.Array\n    ) -> jax.Array:\n        \"\"\"Calls the function (interpolator) on a quad point.\"\"\"\n        return self.element.interpolate(xi, el_nodal_values)\n\n    return self._vmap_over_elements_and_quads(nodal_values, _eval_quad)"
            },
            "grad": {
              "name": "grad",
              "path": "tatva.operator.Operator.grad",
              "signature": "(self, nodal_values) -> jax.Array",
              "description": "Computes the gradient of the nodal values at the quad points.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "nodal_values",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The nodal values at the element's nodes (shape: (n_nodes, n_values))"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.jax.Array",
                "description": "A `jax.Array` with the gradient of the nodal values at each quadrature point"
              },
              "docstring": [],
              "source": "def grad(self, nodal_values: jax.Array) -> jax.Array:\n    \"\"\"Computes the gradient of the nodal values at the quad points.\n\n    Args:\n        nodal_values: The nodal values at the element's nodes (shape: (n_nodes, n_values))\n\n    Returns:\n        A `jax.Array` with the gradient of the nodal values at each quadrature point\n        of each element (shape: (n_elements, n_quad_points, n_values, n_dim)).\n    \"\"\"\n\n    def _gradient_quad(\n        xi: jax.Array, el_nodal_values: jax.Array, el_nodal_coords: jax.Array\n    ) -> jax.Array:\n        \"\"\"Calls the function (gradient) on a quad point.\"\"\"\n        u_grad = self.element.gradient(xi, el_nodal_values, el_nodal_coords)\n        return u_grad\n\n    return self._vmap_over_elements_and_quads(nodal_values, _gradient_quad)"
            },
            "interpolate": {
              "name": "interpolate",
              "path": "tatva.operator.Operator.interpolate",
              "signature": "(self, arg, points) -> jax.Array",
              "description": "Interpolates nodal values to a set of points in the physical space.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "arg",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The nodal values to interpolate."
                    }
                  ]
                },
                {
                  "name": "points",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The points to interpolate the function or nodal values to."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.jax.Array",
                "description": "A `jax.Array` with the interpolated values at the given points."
              },
              "docstring": [],
              "source": "def interpolate(self, arg: jax.Array, points: jax.Array) -> jax.Array:\n    \"\"\"Interpolates nodal values to a set of points in the physical space.\n\n    Args:\n        arg: The nodal values to interpolate.\n        points: The points to interpolate the function or nodal values to.\n\n    Returns:\n        A `jax.Array` with the interpolated values at the given points.\n    \"\"\"\n\n    @jax.jit\n    def compute_rhs(point: jax.Array, nodal_coords: jax.Array) -> jax.Array:\n        xi0 = self.element.quad_points[0]\n        x0, _, _ = self.element.get_local_values(xi0, nodal_coords, nodal_coords)\n        return x0 - point\n\n    @jax.jit\n    def compute_lhs(nodal_coords: jax.Array) -> jax.Array:\n        dfdxi = jax.jacrev(self.element.get_local_values)\n        return dfdxi(self.element.quad_points[0], nodal_coords, nodal_coords)[0]\n\n    @autovmap(point=1, nodal_coords=2)\n    def _map_physical_to_reference(\n        point: jax.Array, nodal_coords: jax.Array\n    ) -> jax.Array:\n        rhs = compute_rhs(point, nodal_coords)\n        lhs = compute_lhs(nodal_coords)\n        delta_xi = jnp.linalg.solve(lhs, -rhs)\n        return self.element.quad_points[0] + delta_xi\n\n    def map_physical_to_reference(points: jax.Array) -> tuple[jax.Array, jax.Array]:\n        element_indices = find_containing_polygons(\n            points, self.mesh.coords[self.mesh.elements]\n        )\n        valid_indices = element_indices != -1\n        return (\n            _map_physical_to_reference(\n                points[valid_indices],\n                self.mesh.coords[\n                    self.mesh.elements[element_indices[valid_indices]]\n                ],\n            ),\n            self.mesh.elements[element_indices[valid_indices]],\n        )\n\n    valid_quad_points, valid_elements = map_physical_to_reference(points)\n\n    if valid_quad_points.shape[0] != points.shape[0]:\n        raise RuntimeError(\"Some points are outside the mesh, revise the points\")\n\n    return self._interpolate_direct(arg, valid_quad_points, valid_elements)"
            },
            "_interpolate_direct": {
              "name": "_interpolate_direct",
              "path": "tatva.operator.Operator._interpolate_direct",
              "signature": "(self, nodal_values, valid_quad_points, valid_elements) -> jax.Array",
              "description": "Interpolates the given nodal values at the quad points.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "nodal_values",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The nodal values at the element's nodes (shape: (n_nodes, n_values))"
                    }
                  ]
                },
                {
                  "name": "valid_quad_points",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The quadrature points in the reference element\n(shape: (n_valid_points, n_dim))"
                    }
                  ]
                },
                {
                  "name": "valid_elements",
                  "annotation": "jax.jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The indices of the elements containing the quadrature points\n(shape: (n_valid_points,))"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.jax.Array",
                "description": "A `jax.Array` with the values of the nodal values at each quadrature point of"
              },
              "docstring": [],
              "source": "def _interpolate_direct(\n    self,\n    nodal_values: jax.Array,\n    valid_quad_points: jax.Array,\n    valid_elements: jax.Array,\n) -> jax.Array:\n    \"\"\"Interpolates the given nodal values at the quad points.\n\n    Args:\n        nodal_values: The nodal values at the element's nodes (shape: (n_nodes, n_values))\n        valid_quad_points: The quadrature points in the reference element\n            (shape: (n_valid_points, n_dim))\n        valid_elements: The indices of the elements containing the quadrature points\n            (shape: (n_valid_points,))\n\n    Returns:\n        A `jax.Array` with the values of the nodal values at each quadrature point of\n        each element (shape: (n_valid_points, n_values)).\n    \"\"\"\n\n    def _interpolate_quad(\n        xi: jax.Array, el_nodal_values: jax.Array, el_nodal_coords: jax.Array\n    ) -> jax.Array:\n        \"\"\"Calls the function (interpolator) on a quad point.\"\"\"\n        return self.element.interpolate(xi, el_nodal_values)\n\n    return eqx.filter_vmap(\n        _interpolate_quad,\n        in_axes=(0, 0, 0),\n    )(\n        valid_quad_points,\n        nodal_values[valid_elements],\n        self.mesh.coords[valid_elements],\n    )"
            }
          },
          "source": "class Operator(Generic[ElementT], eqx.Module):\n    \"\"\"A class that provides an Operator for finite element method (FEM) assembly.\n\n    Args:\n        mesh: The mesh containing the elements and nodes.\n        element: The element type used for the finite element method.\n\n    Provides several operators for evaluating and integrating functions over the mesh,\n    such as `integrate`, `eval`, and `grad`. These operators can be used to compute\n    integrals, evaluate functions at quadrature points, and compute gradients of\n    functions at quadrature points.\n\n    Example:\n        >>> from tatva import Mesh, Tri3, Operator\n        >>> mesh = Mesh.unit_square(10, 10)  # Create a mesh\n        >>> element = Tri3()  # Define an element type\n        >>> operator = Operator(mesh, element)\n        >>> nodal_values = jnp.array(...)  # Nodal values at the mesh nodes\n        >>> energy = operator.integrate(energy_density)(nodal_values)\n    \"\"\"\n\n    mesh: Mesh\n    element: ElementT\n    det_J_elements_weights: Array\n\n    def __init__(self, mesh: Mesh, element: Element):\n        self.mesh = mesh\n        self.element = element\n\n        def _get_det_J(xi: jax.Array, el_nodal_coords: jax.Array) -> jax.Array:\n            \"\"\"Calls the function element.get_jacobian and returns the second output.\"\"\"\n            return self.element.get_jacobian(xi, el_nodal_coords)[1]\n\n        det_J_elements = self.map(_get_det_J)(self.mesh.coords)\n        self.det_J_elements_weights = jnp.einsum(\n            \"eq,q->eq\", det_J_elements, self.element.quad_weights\n        )\n\n    def __check_init__(self) -> None:\n        \"\"\"Validates the mesh and element compatibility. Does a series of checks to ensure\n        that the mesh and element are useable together.\n\n        Raises:\n            ValueError: If the mesh or element are not compatible.\n            TypeError: If the mesh element connectivity is not of integer type.\n        \"\"\"\n        coords = self.mesh.coords\n        elements = self.mesh.elements\n        quad_points = self.element.quad_points\n\n        if coords.ndim != 2:\n            raise ValueError(\n                \"Mesh coordinates must be a 2D array shaped (n_nodes, n_dim).\"\n            )\n        if coords.shape[0] == 0:\n            raise ValueError(\"Mesh must contain at least one node.\")\n\n        if elements.ndim != 2:\n            raise ValueError(\n                \"Mesh elements must be a 2D array shaped (n_elements, n_nodes_per_element).\"\n            )\n        if elements.shape[0] == 0:\n            raise ValueError(\"Mesh must contain at least one element.\")\n        if not jnp.issubdtype(elements.dtype, jnp.integer):\n            raise TypeError(\"Mesh element connectivity must contain integer indices.\")\n\n        if quad_points.ndim != 2 or quad_points.shape[0] == 0:\n            raise ValueError(\n                \"Element must define at least one quadrature point in an (n_q, n_dim) array.\"\n            )\n\n        local_dim = quad_points.shape[1]\n        global_dim = coords.shape[1]\n        if local_dim > 1 and local_dim != global_dim:\n            raise ValueError(\n                f\"Element {self.element.__class__.__name__} expects {local_dim}D coordinates but mesh provides {global_dim}D nodes.\"\n            )\n        if local_dim == 0:\n            raise ValueError(\"Element must have a positive number of local dimensions.\")\n\n        n_nodes_per_element = elements.shape[1]\n        shape_fn = np.asarray(self.element.shape_function(self.element.quad_points[0]))\n        if shape_fn.ndim != 1:\n            raise ValueError(\n                \"Element shape function must return a 1D array of nodal weights.\"\n            )\n        if shape_fn.shape[0] != n_nodes_per_element:\n            raise ValueError(\n                f\"Mesh connectivity lists {n_nodes_per_element} nodes per element but {self.element.__class__.__name__} expects {shape_fn.shape[0]}.\"\n            )\n\n        flat_elements = elements.ravel()\n        if flat_elements.min() < 0:\n            raise ValueError(\n                \"Mesh element connectivity contains negative node indices.\"\n            )\n        if flat_elements.max() >= coords.shape[0]:\n            raise ValueError(\n                \"Mesh element connectivity references nodes outside the mesh coordinates array.\"\n            )\n\n    def _vmap_over_elements_and_quads(\n        self, nodal_values: jax.Array, func: MappableOverElementsAndQuads\n    ) -> jax.Array:\n        \"\"\"Helper function. Maps a function over the elements and quadrature points of the\n        mesh.\n\n        Args:\n            nodal_values: The nodal values at the element's nodes (shape: (n_nodes, n_values))\n            func: The function to map over the elements and quadrature points.\n\n        Returns:\n            A jax.Array with the results of the function applied at each quadrature point\n            of each element (shape: (n_elements, n_quad_points, n_values)).\n        \"\"\"\n\n        def _at_each_element(\n            el_nodal_values: jax.Array, el_nodal_coords: jax.Array\n        ) -> jax.Array:\n            return eqx.filter_vmap(\n                partial(\n                    func,\n                    el_nodal_values=el_nodal_values,\n                    el_nodal_coords=el_nodal_coords,\n                )\n            )(self.element.quad_points)\n\n        return eqx.filter_vmap(\n            _at_each_element,\n            in_axes=(0, 0),\n        )(nodal_values[self.mesh.elements], self.mesh.coords[self.mesh.elements])\n\n    def map(\n        self,\n        func: MappableOverElementsAndQuads[P, RT],\n        *,\n        element_quantity: Sequence[int] = (),\n    ) -> MappedCallable[P, RT]:\n        \"\"\"Maps a function over the elements and quad points of the mesh.\n\n        Returns a function that takes values at nodal points (globally) and returns the\n        vmapped result over the elements and quad points.\n\n        Args:\n            func: The function to map over the elements and quadrature points.\n            element_quantity: Indices of the arguments of `func` that are quantities\n                defined per element. The rest of the arguments are assumed to be defined\n                at nodal points.\n        \"\"\"\n\n        def _mapped(*values: P.args, **kwargs: P.kwargs) -> RT:\n            # values should be arrays!\n            _values = cast(tuple[jax.Array, ...], values)\n\n            def _at_each_element(*el_values) -> jax.Array:\n                return eqx.filter_vmap(\n                    lambda xi: func(xi, *el_values, **kwargs),\n                )(self.element.quad_points)\n\n            return eqx.filter_vmap(\n                _at_each_element,\n                in_axes=(0,) * len(values),\n            )(\n                *(\n                    v[self.mesh.elements] if i not in element_quantity else v\n                    for i, v in enumerate(_values)\n                )\n            )\n\n        return _mapped\n\n    def map_over_elements(\n        self,\n        func: MappableOverElements[P, RT],\n        *,\n        element_quantity: Sequence[int] = (),\n    ) -> MappedCallable[P, RT]:\n        \"\"\"Maps a function over the elements of the mesh.\n\n        Returns a function that takes values at nodal points (globally) and returns the\n        vmapped result over the elements.\n\n        Args:\n            func: The function to map over the elements.\n            element_quantity: Indices of the arguments of `func` that are quantities\n                defined per element. The rest of the arguments are assumed to be defined\n                at nodal points.\n        \"\"\"\n\n        def _mapped(*values: P.args, **kwargs: P.kwargs) -> RT:\n            # values should be arrays!\n            _values = cast(tuple[jax.Array, ...], values)\n\n            def _at_each_element(*el_values) -> RT:\n                return func(*el_values, **kwargs)\n\n            return eqx.filter_vmap(\n                _at_each_element,\n                in_axes=(0,) * len(values),\n            )(\n                *(\n                    v[self.mesh.elements] if i not in element_quantity else v\n                    for i, v in enumerate(_values)\n                )\n            )\n\n        return _mapped\n\n    def integrate(self, arg: jax.Array | Numeric) -> jax.Array:\n        \"\"\"Integrate a nodal_array, quad_array, or numeric value over the mesh.\n\n        Args:\n            arg: An array of nodal values (shape: (n_nodes, n_values)), an array of\n                quadrature values (shape: (n_elements, n_quad_points, n_values)), or a\n                numeric value (float or int).\n\n        Returns:\n            The integral of the nodal values or quadrature values over the mesh.\n        \"\"\"\n        res = self.integrate_per_element(arg)\n        return jnp.sum(res, axis=(0,))  # Sum over elements and quadrature points\n\n    def integrate_per_element(self, arg: jax.Array | Numeric) -> jax.Array:\n        \"\"\"Integrate a nodal_array, quad_array, or numeric value over the mesh. Returning the\n        integral per element.\n\n        Args:\n            arg: An array of nodal values (shape: (n_nodes, n_values)), an array of\n                quadrature values (shape: (n_elements, n_quad_points, n_values)), or a\n                numeric value (float or int).\n\n        Returns:\n            A `jax.Array` where each element contains the integral of the values in the\n            element (shape: (n_elements, n_values)).\n        \"\"\"\n        if isinstance(arg, Numeric):\n            res = self._integrate_quad_array(self.eval(jnp.array([arg])))\n        elif arg.shape[0] == self.mesh.elements.shape[0]:  # element field\n            res = self._integrate_quad_array(arg)\n        else:  # nodal field\n            field_at_quads = self.eval(arg)\n            res = self._integrate_quad_array(field_at_quads)\n\n        return res\n\n    def _integrate_quad_array(self, quad_values: jax.Array) -> jax.Array:\n        \"\"\"Integrates a given array of values at quadrature points over the mesh.\n\n        Args:\n            quad_values: The values at the quadrature points\n                (shape: (n_elements, n_quad_points, n_values))\n\n        Returns:\n            A `jax.Array` where each element contains the integral of the values in the\n            element (shape: (n_elements, n_values)).\n        \"\"\"\n\n        return jnp.einsum(\"eq...,eq->e...\", quad_values, self.det_J_elements_weights)\n\n    def eval(self, nodal_values: jax.Array) -> jax.Array:\n        \"\"\"Evaluates the nodal values at the quadrature points.\n\n        Args:\n            nodal_values: The nodal values at the element's nodes (shape: (n_nodes, n_values))\n\n        Returns:\n            A `jax.Array` with the values of the nodal values at each quadrature point of\n            each element (shape: (n_elements, n_quad_points, n_values)).\n        \"\"\"\n\n        def _eval_quad(\n            xi: jax.Array, el_nodal_values: jax.Array, el_nodal_coords: jax.Array\n        ) -> jax.Array:\n            \"\"\"Calls the function (interpolator) on a quad point.\"\"\"\n            return self.element.interpolate(xi, el_nodal_values)\n\n        return self._vmap_over_elements_and_quads(nodal_values, _eval_quad)\n\n    def grad(self, nodal_values: jax.Array) -> jax.Array:\n        \"\"\"Computes the gradient of the nodal values at the quad points.\n\n        Args:\n            nodal_values: The nodal values at the element's nodes (shape: (n_nodes, n_values))\n\n        Returns:\n            A `jax.Array` with the gradient of the nodal values at each quadrature point\n            of each element (shape: (n_elements, n_quad_points, n_values, n_dim)).\n        \"\"\"\n\n        def _gradient_quad(\n            xi: jax.Array, el_nodal_values: jax.Array, el_nodal_coords: jax.Array\n        ) -> jax.Array:\n            \"\"\"Calls the function (gradient) on a quad point.\"\"\"\n            u_grad = self.element.gradient(xi, el_nodal_values, el_nodal_coords)\n            return u_grad\n\n        return self._vmap_over_elements_and_quads(nodal_values, _gradient_quad)\n\n    def interpolate(self, arg: jax.Array, points: jax.Array) -> jax.Array:\n        \"\"\"Interpolates nodal values to a set of points in the physical space.\n\n        Args:\n            arg: The nodal values to interpolate.\n            points: The points to interpolate the function or nodal values to.\n\n        Returns:\n            A `jax.Array` with the interpolated values at the given points.\n        \"\"\"\n\n        @jax.jit\n        def compute_rhs(point: jax.Array, nodal_coords: jax.Array) -> jax.Array:\n            xi0 = self.element.quad_points[0]\n            x0, _, _ = self.element.get_local_values(xi0, nodal_coords, nodal_coords)\n            return x0 - point\n\n        @jax.jit\n        def compute_lhs(nodal_coords: jax.Array) -> jax.Array:\n            dfdxi = jax.jacrev(self.element.get_local_values)\n            return dfdxi(self.element.quad_points[0], nodal_coords, nodal_coords)[0]\n\n        @autovmap(point=1, nodal_coords=2)\n        def _map_physical_to_reference(\n            point: jax.Array, nodal_coords: jax.Array\n        ) -> jax.Array:\n            rhs = compute_rhs(point, nodal_coords)\n            lhs = compute_lhs(nodal_coords)\n            delta_xi = jnp.linalg.solve(lhs, -rhs)\n            return self.element.quad_points[0] + delta_xi\n\n        def map_physical_to_reference(points: jax.Array) -> tuple[jax.Array, jax.Array]:\n            element_indices = find_containing_polygons(\n                points, self.mesh.coords[self.mesh.elements]\n            )\n            valid_indices = element_indices != -1\n            return (\n                _map_physical_to_reference(\n                    points[valid_indices],\n                    self.mesh.coords[\n                        self.mesh.elements[element_indices[valid_indices]]\n                    ],\n                ),\n                self.mesh.elements[element_indices[valid_indices]],\n            )\n\n        valid_quad_points, valid_elements = map_physical_to_reference(points)\n\n        if valid_quad_points.shape[0] != points.shape[0]:\n            raise RuntimeError(\"Some points are outside the mesh, revise the points\")\n\n        return self._interpolate_direct(arg, valid_quad_points, valid_elements)\n\n    def _interpolate_direct(\n        self,\n        nodal_values: jax.Array,\n        valid_quad_points: jax.Array,\n        valid_elements: jax.Array,\n    ) -> jax.Array:\n        \"\"\"Interpolates the given nodal values at the quad points.\n\n        Args:\n            nodal_values: The nodal values at the element's nodes (shape: (n_nodes, n_values))\n            valid_quad_points: The quadrature points in the reference element\n                (shape: (n_valid_points, n_dim))\n            valid_elements: The indices of the elements containing the quadrature points\n                (shape: (n_valid_points,))\n\n        Returns:\n            A `jax.Array` with the values of the nodal values at each quadrature point of\n            each element (shape: (n_valid_points, n_values)).\n        \"\"\"\n\n        def _interpolate_quad(\n            xi: jax.Array, el_nodal_values: jax.Array, el_nodal_coords: jax.Array\n        ) -> jax.Array:\n            \"\"\"Calls the function (interpolator) on a quad point.\"\"\"\n            return self.element.interpolate(xi, el_nodal_values)\n\n        return eqx.filter_vmap(\n            _interpolate_quad,\n            in_axes=(0, 0, 0),\n        )(\n            valid_quad_points,\n            nodal_values[valid_elements],\n            self.mesh.coords[valid_elements],\n        )",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "lifter": {
      "name": "lifter",
      "path": "tatva.lifter",
      "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/lifter.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Constraint": {
          "name": "Constraint",
          "path": "tatva.lifter.Constraint",
          "description": "Abstract base class for conditions applied during lifting.\n\nSubclasses define how constrained degrees of freedom (dofs) are enforced\nwhen mapping a reduced vector back to the full vector.",
          "parameters": [],
          "attributes": [
            {
              "name": "dofs",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "The constrained dofs (an array of integer indices)."
                }
              ],
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__hash__": {
              "name": "__hash__",
              "path": "tatva.lifter.Constraint.__hash__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __hash__(self):\n    return hash((type(self), tuple(self.dofs.tolist())))"
            },
            "apply_lift": {
              "name": "apply_lift",
              "path": "tatva.lifter.Constraint.apply_lift",
              "signature": "(self, u_full) -> Array",
              "description": "Apply the constraint to a full vector and return the modified copy.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "u_full",
                  "annotation": "jax.Array",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def apply_lift(self, u_full: Array) -> Array:  # override in subclasses\n    \"\"\"Apply the constraint to a full vector and return the modified copy.\"\"\"\n    return u_full"
            }
          },
          "source": "class Constraint(ABC):\n    \"\"\"Abstract base class for conditions applied during lifting.\n\n    Subclasses define how constrained degrees of freedom (dofs) are enforced\n    when mapping a reduced vector back to the full vector.\n    \"\"\"\n\n    dofs: Array\n    \"\"\"The constrained dofs (an array of integer indices).\"\"\"\n\n    def __hash__(self):\n        return hash((type(self), tuple(self.dofs.tolist())))\n\n    def apply_lift(self, u_full: Array) -> Array:  # override in subclasses\n        \"\"\"Apply the constraint to a full vector and return the modified copy.\"\"\"\n        return u_full",
          "inherited_members": {}
        },
        "PeriodicMap": {
          "name": "PeriodicMap",
          "path": "tatva.lifter.PeriodicMap",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "dofs",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            },
            {
              "name": "master_dofs",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "dofs",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            },
            {
              "name": "master_dofs",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "apply_lift": {
              "name": "apply_lift",
              "path": "tatva.lifter.PeriodicMap.apply_lift",
              "signature": "(self, u_full) -> Array",
              "description": "Copy values from ``master_dofs`` into the constrained ``dofs``.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "u_full",
                  "annotation": "jax.Array",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def apply_lift(self, u_full: Array) -> Array:\n    \"\"\"Copy values from ``master_dofs`` into the constrained ``dofs``.\"\"\"\n    return u_full.at[self.dofs].set(u_full[self.master_dofs])"
            },
            "__init__": {
              "name": "__init__",
              "path": "tatva.lifter.PeriodicMap.__init__",
              "signature": "(self, dofs, master_dofs) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "dofs",
                  "annotation": "jax.Array",
                  "description": null,
                  "value": null
                },
                {
                  "name": "master_dofs",
                  "annotation": "jax.Array",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass PeriodicMap(Constraint):\n    dofs: Array\n    master_dofs: Array\n\n    def apply_lift(self, u_full: Array) -> Array:\n        \"\"\"Copy values from ``master_dofs`` into the constrained ``dofs``.\"\"\"\n        return u_full.at[self.dofs].set(u_full[self.master_dofs])",
          "inherited_members": {
            "tatva.lifter.Constraint": [
              {
                "kind": "function",
                "path": "tatva.lifter.Constraint.__hash__"
              }
            ]
          }
        },
        "DirichletBC": {
          "name": "DirichletBC",
          "path": "tatva.lifter.DirichletBC",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "dofs",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            },
            {
              "name": "values",
              "annotation": "jax.Array | None",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "dofs",
              "annotation": "jax.Array",
              "description": null,
              "value": "tatva.lifter.DirichletBC(dofs)"
            },
            {
              "name": "values",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "tatva.lifter.DirichletBC.__init__",
              "signature": "(self, dofs, values=None)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "dofs",
                  "annotation": "jax.Array",
                  "description": null,
                  "value": null
                },
                {
                  "name": "values",
                  "annotation": "jax.Array | None",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, dofs: Array, values: Array | None = None):\n    self.dofs = dofs\n    if values is None:\n        self.values = jnp.zeros(dofs.shape, dtype=jnp.float64)\n    else:\n        self.values = values"
            },
            "apply_lift": {
              "name": "apply_lift",
              "path": "tatva.lifter.DirichletBC.apply_lift",
              "signature": "(self, u_full) -> Array",
              "description": "Set constrained ``dofs`` to fixed ``values``.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "u_full",
                  "annotation": "jax.Array",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def apply_lift(self, u_full: Array) -> Array:\n    \"\"\"Set constrained ``dofs`` to fixed ``values``.\"\"\"\n    return u_full.at[self.dofs].set(self.values)"
            }
          },
          "source": "class DirichletBC(Constraint):\n    dofs: Array\n    values: Array\n\n    def __init__(self, dofs: Array, values: Array | None = None):\n        self.dofs = dofs\n        if values is None:\n            self.values = jnp.zeros(dofs.shape, dtype=jnp.float64)\n        else:\n            self.values = values\n\n    def apply_lift(self, u_full: Array) -> Array:\n        \"\"\"Set constrained ``dofs`` to fixed ``values``.\"\"\"\n        return u_full.at[self.dofs].set(self.values)",
          "inherited_members": {
            "tatva.lifter.Constraint": [
              {
                "kind": "function",
                "path": "tatva.lifter.Constraint.__hash__"
              }
            ]
          }
        },
        "Lifter": {
          "name": "Lifter",
          "path": "tatva.lifter.Lifter",
          "description": "Create a lifter that maps between reduced and full vectors.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "size",
              "annotation": "int",
              "description": [
                {
                  "kind": "text",
                  "value": "Total number of dofs in the full vector."
                }
              ]
            },
            {
              "name": "constraints",
              "annotation": "tatva.lifter.Constraint",
              "description": null,
              "value": "()"
            },
            {
              "name": "kwargs",
              "annotation": null,
              "description": null,
              "value": "{}"
            }
          ],
          "attributes": [
            {
              "name": "free_dofs",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "Array of free dofs as integer indices (not constrained)."
                }
              ],
              "value": null
            },
            {
              "name": "constrained_dofs",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "Array of constrained dofs as integer indices."
                }
              ],
              "value": null
            },
            {
              "name": "size",
              "annotation": "int",
              "description": [
                {
                  "kind": "text",
                  "value": "Total number of dofs in the full vector."
                }
              ],
              "value": "tatva.lifter.Lifter(size)"
            },
            {
              "name": "size_reduced",
              "annotation": "int",
              "description": [
                {
                  "kind": "text",
                  "value": "Number of dofs in the reduced vector (free dofs only)."
                }
              ],
              "value": null
            },
            {
              "name": "constraints",
              "annotation": "tuple[tatva.lifter.Constraint, ...]",
              "description": [
                {
                  "kind": "text",
                  "value": "Tuple of additional constraints (e.g., periodic maps)."
                }
              ],
              "value": "tatva.lifter.Lifter(constraints)"
            }
          ],
          "docstring": [
            {
              "kind": "text",
              "value": "Examples::\n\n    lifter = Lifter(\n        6,\n        DirichletBC(jnp.array([0, 5])),\n        PeriodicMap(dofs=jnp.array([2]), master_dofs=jnp.array([1])),\n    )\n    u_reduced = jnp.array([10.0, 20.0, 30.0])\n    u_full = lifter.lift_from_null(u_reduced)\n    # u_full -> [0., 10., 10., 20., 30., 0.]\n    u_reduced_back = lifter.reduce(u_full)"
            }
          ],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "tatva.lifter.Lifter.__init__",
              "signature": "(self, size, *constraints, **kwargs)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "size",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "constraints",
                  "annotation": "tatva.lifter.Constraint",
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    size: int,\n    /,\n    *constraints: Constraint,\n    **kwargs,\n):\n    self.size = size\n    self.constraints = constraints\n\n    self._compute_sizes()"
            },
            "__hash__": {
              "name": "__hash__",
              "path": "tatva.lifter.Lifter.__hash__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __hash__(self):\n    return hash((self.size, self.constraints))"
            },
            "_compute_sizes": {
              "name": "_compute_sizes",
              "path": "tatva.lifter.Lifter._compute_sizes",
              "signature": "(self)",
              "description": "Compute free/constrained dofs and reduced size.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _compute_sizes(self):\n    \"\"\"Compute free/constrained dofs and reduced size.\"\"\"\n    all_dofs = jnp.arange(self.size)\n\n    if not self.constraints:\n        # base case: no constraints\n        self.free_dofs = all_dofs\n        self.constrained_dofs = jnp.array([], dtype=jnp.int32)\n        self.size_reduced = self.size\n        return\n\n    constrained = jnp.concatenate([cond.dofs for cond in self.constraints])\n    constrained = jnp.unique(constrained)\n    free = jnp.setdiff1d(all_dofs, constrained, assume_unique=True)\n\n    self.free_dofs = free\n    self.constrained_dofs = constrained\n    self.size_reduced = free.size"
            },
            "add": {
              "name": "add",
              "path": "tatva.lifter.Lifter.add",
              "signature": "(self, condition) -> Self",
              "description": "Return a new lifter with ``condition`` appended to constraints.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "condition",
                  "annotation": "tatva.lifter.Constraint",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def add(self, condition: Constraint) -> Self:\n    \"\"\"Return a new lifter with ``condition`` appended to constraints.\"\"\"\n    return self.__class__(self.size, *self.constraints, condition)"
            },
            "lift": {
              "name": "lift",
              "path": "tatva.lifter.Lifter.lift",
              "signature": "(self, u_reduced, u_full) -> Array",
              "description": "Lift reduced displacement vector to full size.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "u_reduced",
                  "annotation": "jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Vector on free dofs (length ``size_reduced``)."
                    }
                  ]
                },
                {
                  "name": "u_full",
                  "annotation": "jax.Array",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Base full vector to modify; typically previous solution."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "jax.Array",
                "description": "Full vector with free dofs set to ``u_reduced`` and constraints"
              },
              "docstring": [],
              "source": "def lift(self, u_reduced: Array, u_full: Array) -> Array:\n    \"\"\"Lift reduced displacement vector to full size.\n\n    Args:\n        u_reduced: Vector on free dofs (length ``size_reduced``).\n        u_full: Base full vector to modify; typically previous solution.\n\n    Returns:\n        Full vector with free dofs set to ``u_reduced`` and constraints\n        applied (Dirichlet, periodic, etc.).\n    \"\"\"\n    u_full = u_full.at[self.free_dofs].set(u_reduced)\n    for condition in self.constraints:\n        u_full = condition.apply_lift(u_full)\n    return u_full"
            },
            "lift_from_zeros": {
              "name": "lift_from_zeros",
              "path": "tatva.lifter.Lifter.lift_from_zeros",
              "signature": "(self, u_reduced) -> Array",
              "description": "Lift reduced vector to a full vector starting from zeros.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "u_reduced",
                  "annotation": "jax.Array",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def lift_from_zeros(self, u_reduced: Array) -> Array:\n    \"\"\"Lift reduced vector to a full vector starting from zeros.\"\"\"\n    u_full = jnp.zeros(self.size, dtype=u_reduced.dtype)\n    return self.lift(u_reduced, u_full)"
            },
            "reduce": {
              "name": "reduce",
              "path": "tatva.lifter.Lifter.reduce",
              "signature": "(self, u_full) -> Array",
              "description": "Extract the reduced vector by selecting free dofs from ``u_full``.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "u_full",
                  "annotation": "jax.Array",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def reduce(self, u_full: Array) -> Array:\n    \"\"\"Extract the reduced vector by selecting free dofs from ``u_full``.\"\"\"\n    return u_full[self.free_dofs]"
            }
          },
          "source": "class Lifter(equinox.Module):\n    \"\"\"Create a lifter that maps between reduced and full vectors.\n\n    Args:\n        size: Total number of dofs in the full vector.\n        *constraints: Extra constraints (e.g., periodic maps).\n        **kwargs: Ignored; kept for compatibility with equinox.Module init.\n\n    Examples::\n\n        lifter = Lifter(\n            6,\n            DirichletBC(jnp.array([0, 5])),\n            PeriodicMap(dofs=jnp.array([2]), master_dofs=jnp.array([1])),\n        )\n        u_reduced = jnp.array([10.0, 20.0, 30.0])\n        u_full = lifter.lift_from_null(u_reduced)\n        # u_full -> [0., 10., 10., 20., 30., 0.]\n        u_reduced_back = lifter.reduce(u_full)\n\n    \"\"\"\n\n    free_dofs: Array\n    \"\"\"Array of free dofs as integer indices (not constrained).\"\"\"\n\n    constrained_dofs: Array\n    \"\"\"Array of constrained dofs as integer indices.\"\"\"\n\n    size: int\n    \"\"\"Total number of dofs in the full vector.\"\"\"\n\n    size_reduced: int\n    \"\"\"Number of dofs in the reduced vector (free dofs only).\"\"\"\n\n    constraints: tuple[Constraint, ...] = ()\n    \"\"\"Tuple of additional constraints (e.g., periodic maps).\"\"\"\n\n    def __init__(\n        self,\n        size: int,\n        /,\n        *constraints: Constraint,\n        **kwargs,\n    ):\n        self.size = size\n        self.constraints = constraints\n\n        self._compute_sizes()\n\n    def __hash__(self):\n        return hash((self.size, self.constraints))\n\n    def _compute_sizes(self):\n        \"\"\"Compute free/constrained dofs and reduced size.\"\"\"\n        all_dofs = jnp.arange(self.size)\n\n        if not self.constraints:\n            # base case: no constraints\n            self.free_dofs = all_dofs\n            self.constrained_dofs = jnp.array([], dtype=jnp.int32)\n            self.size_reduced = self.size\n            return\n\n        constrained = jnp.concatenate([cond.dofs for cond in self.constraints])\n        constrained = jnp.unique(constrained)\n        free = jnp.setdiff1d(all_dofs, constrained, assume_unique=True)\n\n        self.free_dofs = free\n        self.constrained_dofs = constrained\n        self.size_reduced = free.size\n\n    def add(self, condition: Constraint) -> Self:\n        \"\"\"Return a new lifter with ``condition`` appended to constraints.\"\"\"\n        return self.__class__(self.size, *self.constraints, condition)\n\n    def lift(self, u_reduced: Array, u_full: Array) -> Array:\n        \"\"\"Lift reduced displacement vector to full size.\n\n        Args:\n            u_reduced: Vector on free dofs (length ``size_reduced``).\n            u_full: Base full vector to modify; typically previous solution.\n\n        Returns:\n            Full vector with free dofs set to ``u_reduced`` and constraints\n            applied (Dirichlet, periodic, etc.).\n        \"\"\"\n        u_full = u_full.at[self.free_dofs].set(u_reduced)\n        for condition in self.constraints:\n            u_full = condition.apply_lift(u_full)\n        return u_full\n\n    def lift_from_zeros(self, u_reduced: Array) -> Array:\n        \"\"\"Lift reduced vector to a full vector starting from zeros.\"\"\"\n        u_full = jnp.zeros(self.size, dtype=u_reduced.dtype)\n        return self.lift(u_reduced, u_full)\n\n    def reduce(self, u_full: Array) -> Array:\n        \"\"\"Extract the reduced vector by selecting free dofs from ``u_full``.\"\"\"\n        return u_full[self.free_dofs]",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "sparse": {
      "name": "sparse",
      "path": "tatva.sparse",
      "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/sparse.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {},
      "functions": {
        "jacfwd": {
          "name": "jacfwd",
          "path": "tatva.sparse.jacfwd",
          "signature": "(func, sparsity_pattern)",
          "description": null,
          "parameters": [
            {
              "name": "func",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "sparsity_pattern",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def jacfwd(func, sparsity_pattern):\n    return sparsejac.jacfwd(func, sparsity=sparsity_pattern)"
        },
        "jacrev": {
          "name": "jacrev",
          "path": "tatva.sparse.jacrev",
          "signature": "(func, sparsity_pattern)",
          "description": null,
          "parameters": [
            {
              "name": "func",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "sparsity_pattern",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def jacrev(func, sparsity_pattern):\n    return sparsejac.jacrev(func, sparsity=sparsity_pattern)"
        },
        "_create_sparse_structure": {
          "name": "_create_sparse_structure",
          "path": "tatva.sparse._create_sparse_structure",
          "signature": "(elements, n_dofs_per_node, K_shape)",
          "description": "Create a sparse structure for a given set of elements and constraints.\nArgs:\n    elements: (num_elements, nodes_per_element)\n    n_dofs_per_node: Number of degrees of freedom per node\n    K_shape: Shape of the matrix K\nReturns:\n    data: (num_nonzero_elements,)\n    indices: (num_nonzero_elements, 2)",
          "parameters": [
            {
              "name": "elements",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "n_dofs_per_node",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "K_shape",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _create_sparse_structure(elements, n_dofs_per_node, K_shape):\n    \"\"\"\n    Create a sparse structure for a given set of elements and constraints.\n    Args:\n        elements: (num_elements, nodes_per_element)\n        n_dofs_per_node: Number of degrees of freedom per node\n        K_shape: Shape of the matrix K\n    Returns:\n        data: (num_nonzero_elements,)\n        indices: (num_nonzero_elements, 2)\n    \"\"\"\n\n    elements = jnp.array(elements)\n    num_elements, nodes_per_element = elements.shape\n\n    # Compute all (i, j, k, l) combinations for each element\n    i_idx = jnp.repeat(\n        elements, nodes_per_element, axis=1\n    )  # (num_elements, nodes_per_element^2)\n    j_idx = jnp.tile(\n        elements, (1, nodes_per_element)\n    )  # (num_elements, nodes_per_element^2)\n\n    # Expand for n_dofs_per_node\n    k_idx = jnp.arange(n_dofs_per_node, dtype=jnp.int32)\n    l_idx = jnp.arange(n_dofs_per_node, dtype=jnp.int32)\n    k_idx, l_idx = jnp.meshgrid(k_idx, l_idx, indexing=\"ij\")\n    k_idx = k_idx.flatten()\n    l_idx = l_idx.flatten()\n\n    # For each element, get all (row, col) indices\n    def element_indices(i, j):\n        row = n_dofs_per_node * i + k_idx\n        col = n_dofs_per_node * j + l_idx\n        return row, col\n\n    # Vectorize over all (i, j) pairs for all elements\n    row_idx, col_idx = jax.vmap(element_indices)(i_idx.flatten(), j_idx.flatten())\n\n    # Flatten and clip to matrix size\n    row_idx = row_idx.flatten()\n    col_idx = col_idx.flatten()\n    mask = (row_idx < K_shape[0]) & (col_idx < K_shape[1])\n    row_idx = row_idx[mask]\n    col_idx = col_idx[mask]\n\n    # Create the sparse structure\n    indices = np.unique(np.vstack((row_idx, col_idx)).T, axis=0)\n\n    data = np.ones(indices.shape[0], dtype=jnp.int32)\n    sparsity_pattern = jax_sparse.BCOO((data, indices.astype(np.int32)), shape=K_shape)  # type: ignore\n    return sparsity_pattern"
        },
        "get_bc_indices": {
          "name": "get_bc_indices",
          "path": "tatva.sparse.get_bc_indices",
          "signature": "(sparsity_pattern, fixed_dofs)",
          "description": "Get the indices of the fixed degrees of freedom.\nArgs:\n    sparsity_pattern: jax.experimental.sparse.BCOO\n    fixed_dofs: (num_fixed_dofs,)\nReturns:\n    zero_indices: (num_zero_indices,)\n    one_indices: (num_one_indices,)",
          "parameters": [
            {
              "name": "sparsity_pattern",
              "annotation": "jax.experimental.sparse.jax.experimental.sparse.BCOO",
              "description": null,
              "value": null
            },
            {
              "name": "fixed_dofs",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def get_bc_indices(sparsity_pattern: jax_sparse.BCOO, fixed_dofs: Array):\n    \"\"\"\n    Get the indices of the fixed degrees of freedom.\n    Args:\n        sparsity_pattern: jax.experimental.sparse.BCOO\n        fixed_dofs: (num_fixed_dofs,)\n    Returns:\n        zero_indices: (num_zero_indices,)\n        one_indices: (num_one_indices,)\n    \"\"\"\n\n    indices = sparsity_pattern.indices\n    zero_indices = []\n    one_indices = []\n\n    for dof in fixed_dofs:\n        indexes = np.where(indices[:, 0] == dof)[0]\n        for idx in indexes:\n            zero_indices.append(int(idx))\n\n        idx = np.where(np.all(indices == np.array([dof, dof]), axis=1))[0][0]\n        one_indices.append(int(idx))\n\n    return np.array(zero_indices), np.array(one_indices)"
        },
        "create_sparsity_pattern": {
          "name": "create_sparsity_pattern",
          "path": "tatva.sparse.create_sparsity_pattern",
          "signature": "(mesh, n_dofs_per_node, K_shape=None, constraint_elements=None)",
          "description": "Create a sparsity pattern for a given set of elements and constraints.\nArgs:\n    mesh: Mesh object\n    n_dofs_per_node: Number of degrees of freedom per node\n    constraint_elements: Optional array of constraint elements. If provided, the sparsity pattern will be created for the constraint elements.\nReturns:\n    sparsity_pattern: jax.experimental.sparse.BCOO",
          "parameters": [
            {
              "name": "mesh",
              "annotation": "tatva.Mesh",
              "description": null,
              "value": null
            },
            {
              "name": "n_dofs_per_node",
              "annotation": "int",
              "description": null,
              "value": null
            },
            {
              "name": "K_shape",
              "annotation": "typing.Optional[typing.Tuple[int, int]]",
              "description": null,
              "value": "None"
            },
            {
              "name": "constraint_elements",
              "annotation": "typing.Optional[jax.Array]",
              "description": null,
              "value": "None"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def create_sparsity_pattern(\n    mesh: Mesh,\n    n_dofs_per_node: int,\n    K_shape: Optional[Tuple[int, int]] = None,\n    constraint_elements: Optional[Array] = None,\n):\n    \"\"\"\n    Create a sparsity pattern for a given set of elements and constraints.\n    Args:\n        mesh: Mesh object\n        n_dofs_per_node: Number of degrees of freedom per node\n        constraint_elements: Optional array of constraint elements. If provided, the sparsity pattern will be created for the constraint elements.\n    Returns:\n        sparsity_pattern: jax.experimental.sparse.BCOO\n    \"\"\"\n\n    elements = mesh.elements\n\n    if K_shape is None:\n        K_shape = (\n            n_dofs_per_node * mesh.coords.shape[0],\n            n_dofs_per_node * mesh.coords.shape[0],\n        )\n\n    sparsity_pattern = _create_sparse_structure(elements, n_dofs_per_node, K_shape)\n    if constraint_elements is not None:\n        sparsity_pattern_constraint = _create_sparse_structure(\n            constraint_elements, n_dofs_per_node, K_shape\n        )\n\n        combined_data = np.concatenate(\n            [sparsity_pattern.data, sparsity_pattern_constraint.data]\n        )\n        combined_indices = np.concatenate(\n            [sparsity_pattern.indices, sparsity_pattern_constraint.indices]\n        )\n        sparsity_pattern = jax_sparse.BCOO(\n            (combined_data, combined_indices),  # type: ignore\n            shape=K_shape,\n        )\n\n    return sparsity_pattern"
        },
        "create_sparsity_pattern_KKT": {
          "name": "create_sparsity_pattern_KKT",
          "path": "tatva.sparse.create_sparsity_pattern_KKT",
          "signature": "(mesh, n_dofs_per_node, B)",
          "description": "Create a sparsity pattern for the KKT system.\nArgs:\n    mesh: Mesh object\n    n_dofs_per_node: Number of degrees of freedom per node\n    B: Constraint matrix (nb_cons, n_dofs)\nReturns:\n    sparsity_pattern_KKT: jax.experimental.sparse.BCOO",
          "parameters": [
            {
              "name": "mesh",
              "annotation": "tatva.Mesh",
              "description": null,
              "value": null
            },
            {
              "name": "n_dofs_per_node",
              "annotation": "int",
              "description": null,
              "value": null
            },
            {
              "name": "B",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def create_sparsity_pattern_KKT(mesh: Mesh, n_dofs_per_node: int, B: Array):\n    \"\"\"\n    Create a sparsity pattern for the KKT system.\n    Args:\n        mesh: Mesh object\n        n_dofs_per_node: Number of degrees of freedom per node\n        B: Constraint matrix (nb_cons, n_dofs)\n    Returns:\n        sparsity_pattern_KKT: jax.experimental.sparse.BCOO\n    \"\"\"\n\n    nb_cons = B.shape[0]\n\n    K_sparsity_pattern = create_sparsity_pattern(mesh, n_dofs_per_node=n_dofs_per_node)\n    B_sparsity_pattern = jax_sparse.BCOO.fromdense(B).astype(jnp.int32)\n\n    sparsity_pattern_left = jax_sparse.bcoo_concatenate(\n        [K_sparsity_pattern, B_sparsity_pattern], dimension=0\n    )\n\n    BT_sparsity_pattern = jax_sparse.BCOO.fromdense(B.T).astype(jnp.int32)\n    C = jax_sparse.BCOO.fromdense(jnp.eye(nb_cons, nb_cons, dtype=jnp.int32))\n    sparsity_pattern_right = jax_sparse.bcoo_concatenate(\n        [BT_sparsity_pattern, C], dimension=0\n    )\n\n    sparsity_pattern_KKT = jax_sparse.bcoo_concatenate(\n        [sparsity_pattern_left, sparsity_pattern_right], dimension=1\n    )\n\n    return sparsity_pattern_KKT"
        },
        "reduce_sparsity_pattern": {
          "name": "reduce_sparsity_pattern",
          "path": "tatva.sparse.reduce_sparsity_pattern",
          "signature": "(pattern, free_dofs) -> BCOO",
          "description": "Reduce a sparse matrix pattern to only the free dofs (for K_ff).",
          "parameters": [
            {
              "name": "pattern",
              "annotation": "jax.experimental.sparse.bcoo.BCOO",
              "description": [
                {
                  "kind": "text",
                  "value": "Sparse matrix pattern in BCOO format on the full\nset of dofs."
                }
              ]
            },
            {
              "name": "free_dofs",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "Array of free dofs as integer indices."
                }
              ]
            }
          ],
          "returns": {
            "name": "BCOO",
            "annotation": "jax.experimental.sparse.bcoo.BCOO",
            "description": "Reduced sparse matrix pattern with rows and columns remapped\nto the reduced indexing of free dofs."
          },
          "docstring": [],
          "source": "def reduce_sparsity_pattern(pattern: BCOO, free_dofs: Array) -> BCOO:\n    \"\"\"Reduce a sparse matrix pattern to only the free dofs (for K_ff).\n\n    Args:\n        pattern (BCOO): Sparse matrix pattern in BCOO format on the full\n            set of dofs.\n        free_dofs: Array of free dofs as integer indices.\n\n    Returns:\n        BCOO: Reduced sparse matrix pattern with rows and columns remapped\n            to the reduced indexing of free dofs.\n    \"\"\"\n    # Pull to host (avoid device OOM for big masks)\n    I = np.asarray(pattern.indices[:, 0])  # noqa: E741\n    J = np.asarray(pattern.indices[:, 1])\n    D = np.asarray(pattern.data)\n\n    n_full = int(pattern.shape[0])\n    free = np.asarray(free_dofs, dtype=np.int64)\n\n    # Membership mask: O(n_full) setup, O(nnz) index\n    is_free = np.zeros(n_full, dtype=bool)\n    is_free[free] = True\n    mask = is_free[I] & is_free[J]\n\n    I = I[mask]  # noqa: E741\n    J = J[mask]\n    D = D[mask]\n\n    # Full -> reduced reindex\n    index_map = -np.ones(n_full, dtype=np.int64)\n    index_map[free] = np.arange(free.size, dtype=np.int64)\n    I_red = index_map[I]\n    J_red = index_map[J]\n\n    # Deduplicate (sum data; for pure pattern set to 1)\n    keys = I_red * free.size + J_red\n    uniq, inv = np.unique(keys, return_inverse=True)\n    # accumulate\n    D_red = np.bincount(inv, weights=D, minlength=uniq.size)\n    I_red = (uniq // free.size).astype(np.int32)\n    J_red = (uniq % free.size).astype(np.int32)\n\n    # Back to JAX\n    indices_red = jnp.stack([jnp.asarray(I_red), jnp.asarray(J_red)], axis=1)\n    data_red = jnp.asarray(D_red)\n    shape = (free.size, free.size)\n\n    return BCOO((data_red, indices_red), shape=shape)"
        }
      }
    },
    "compound": {
      "name": "compound",
      "path": "tatva.compound",
      "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/compound.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "_field": {
          "name": "_field",
          "path": "tatva.compound._field",
          "description": "A descriptor to define fields in the State class.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "shape",
              "annotation": "tuple[int, ...]",
              "description": null,
              "value": null
            },
            {
              "name": "default_factory",
              "annotation": "typing.Callable | None",
              "description": null,
              "value": "None"
            },
            {
              "name": "slice",
              "annotation": "tatva.compound._field(slice) | None",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "shape",
              "annotation": "tuple[int, ...]",
              "description": null,
              "value": "tatva.compound._field(shape) if len(tatva.compound._field(shape)) > 1 else (*tatva.compound._field(shape), 1)"
            },
            {
              "name": "default_factory",
              "annotation": "typing.Callable | None",
              "description": null,
              "value": "tatva.compound._field(default_factory)"
            },
            {
              "name": "slice",
              "annotation": "tatva.compound._field(slice)",
              "description": null,
              "value": "tatva.compound._field(slice)"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "tatva.compound._field.__init__",
              "signature": "(self, shape, default_factory=None, slice=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "shape",
                  "annotation": "tuple[int, ...]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "default_factory",
                  "annotation": "typing.Callable | None",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "slice",
                  "annotation": "tatva.compound._field(slice) | None",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    shape: tuple[int, ...],\n    default_factory: Callable | None = None,\n    slice: slice | None = None,\n) -> None:\n    self.shape = shape if len(shape) > 1 else (*shape, 1)\n    self.default_factory = default_factory\n    self.slice: slice = slice  # type: ignore"
            },
            "__getitem__": {
              "name": "__getitem__",
              "path": "tatva.compound._field.__getitem__",
              "signature": "(self, arg) -> Array",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "arg",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __getitem__(self, arg) -> Array:\n    # Normalize to tuple\n    if not isinstance(arg, tuple):\n        arg = (arg,)\n    # extend with full slices\n    if len(arg) < len(self.shape):\n        arg = arg + (slice(None),) * (len(self.shape) - len(arg))\n    # build index arrays\n    idxs = []\n    for dim, sub in enumerate(arg):\n        if isinstance(sub, slice):\n            start, stop, step = sub.indices(self.shape[dim])\n            idxs.append(jnp.arange(start, stop, step))\n        elif isinstance(sub, (int, jnp.integer)):\n            idxs.append(jnp.array([sub]))\n        else:\n            idxs.append(jnp.asarray(sub))\n\n    mesh = jnp.meshgrid(*idxs, indexing=\"ij\")\n    multi_idx = [m.flatten() for m in mesh]\n    flat_local = jnp.ravel_multi_index(multi_idx, dims=self.shape)\n\n    return jnp.array(flat_local + self.slice.start)"
            }
          },
          "source": "class _field:\n    \"\"\"A descriptor to define fields in the State class.\"\"\"\n\n    shape: tuple[int, ...]\n    default_factory: Callable | None\n\n    def __init__(\n        self,\n        shape: tuple[int, ...],\n        default_factory: Callable | None = None,\n        slice: slice | None = None,\n    ) -> None:\n        self.shape = shape if len(shape) > 1 else (*shape, 1)\n        self.default_factory = default_factory\n        self.slice: slice = slice  # type: ignore\n\n    def __getitem__(self, arg) -> Array:\n        # Normalize to tuple\n        if not isinstance(arg, tuple):\n            arg = (arg,)\n        # extend with full slices\n        if len(arg) < len(self.shape):\n            arg = arg + (slice(None),) * (len(self.shape) - len(arg))\n        # build index arrays\n        idxs = []\n        for dim, sub in enumerate(arg):\n            if isinstance(sub, slice):\n                start, stop, step = sub.indices(self.shape[dim])\n                idxs.append(jnp.arange(start, stop, step))\n            elif isinstance(sub, (int, jnp.integer)):\n                idxs.append(jnp.array([sub]))\n            else:\n                idxs.append(jnp.asarray(sub))\n\n        mesh = jnp.meshgrid(*idxs, indexing=\"ij\")\n        multi_idx = [m.flatten() for m in mesh]\n        flat_local = jnp.ravel_multi_index(multi_idx, dims=self.shape)\n\n        return jnp.array(flat_local + self.slice.start)",
          "inherited_members": {}
        },
        "field": {
          "name": "field",
          "path": "tatva.compound.field",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "shape",
              "annotation": "tuple[int, ...]",
              "description": null,
              "value": null
            },
            {
              "name": "default_factory",
              "annotation": "typing.Callable | None",
              "description": null,
              "value": "None"
            },
            {
              "name": "slice",
              "annotation": "tatva.compound._field(slice) | None",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__get__": {
              "name": "__get__",
              "path": "tatva.compound.field.__get__",
              "signature": "(self, instance, owner=None)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "instance",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "owner",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __get__(self, instance, owner=None):\n    if instance is None:\n        return self\n    # get slice\n    return instance.arr[self.slice].reshape(self.shape)"
            },
            "__set__": {
              "name": "__set__",
              "path": "tatva.compound.field.__set__",
              "signature": "(self, instance, value) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "instance",
                  "annotation": "tatva.compound.Compound",
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": "jax.Array | float | int",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __set__(self, instance: Compound, value: Array | float | int) -> None:\n    arr = jnp.asarray(value)\n    instance.arr = instance.arr.at[self.slice].set(arr.flatten())"
            },
            "__delete__": {
              "name": "__delete__",
              "path": "tatva.compound.field.__delete__",
              "signature": "(self, instance)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "instance",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __delete__(self, instance):\n    raise AttributeError(\n        f\"Cannot delete field ... from {instance.__class__.__name__}.\"\n    )"
            }
          },
          "source": "class field(_field):\n    @overload\n    def __get__(self, instance: None, owner) -> field: ...\n    @overload\n    def __get__(self, instance: Compound, owner) -> Array: ...\n    def __get__(self, instance, owner=None):\n        if instance is None:\n            return self\n        # get slice\n        return instance.arr[self.slice].reshape(self.shape)\n\n    def __set__(self, instance: Compound, value: Array | float | int) -> None:\n        arr = jnp.asarray(value)\n        instance.arr = instance.arr.at[self.slice].set(arr.flatten())\n\n    def __delete__(self, instance):\n        raise AttributeError(\n            f\"Cannot delete field ... from {instance.__class__.__name__}.\"\n        )",
          "inherited_members": {
            "tatva.compound._field": [
              {
                "kind": "attribute",
                "path": "tatva.compound._field.shape"
              },
              {
                "kind": "attribute",
                "path": "tatva.compound._field.default_factory"
              },
              {
                "kind": "function",
                "path": "tatva.compound._field.__init__"
              },
              {
                "kind": "attribute",
                "path": "tatva.compound._field.slice"
              },
              {
                "kind": "function",
                "path": "tatva.compound._field.__getitem__"
              }
            ]
          }
        },
        "_field_sub_of_stack": {
          "name": "_field_sub_of_stack",
          "path": "tatva.compound._field_sub_of_stack",
          "description": "A descriptor to define fields that are sub-fields of a stacked field in the State class.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "shape",
              "annotation": "tuple[int, ...]",
              "description": null,
              "value": null
            },
            {
              "name": "parent_field",
              "annotation": "tatva.compound._field",
              "description": null,
              "value": null
            },
            {
              "name": "parent_slice",
              "annotation": "tuple[slice, ...]",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "parent_field",
              "annotation": null,
              "description": null,
              "value": "tatva.compound._field_sub_of_stack(parent_field)"
            },
            {
              "name": "parent_slice",
              "annotation": null,
              "description": null,
              "value": "tatva.compound._field_sub_of_stack(parent_slice)"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "tatva.compound._field_sub_of_stack.__init__",
              "signature": "(self, shape, parent_field, parent_slice) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "shape",
                  "annotation": "tuple[int, ...]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "parent_field",
                  "annotation": "tatva.compound._field",
                  "description": null,
                  "value": null
                },
                {
                  "name": "parent_slice",
                  "annotation": "tuple[slice, ...]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    shape: tuple[int, ...],\n    parent_field: _field,\n    parent_slice: tuple[slice, ...],\n) -> None:\n    super().__init__(shape)\n    self.parent_field = parent_field\n    self.parent_slice = parent_slice"
            },
            "__get__": {
              "name": "__get__",
              "path": "tatva.compound._field_sub_of_stack.__get__",
              "signature": "(self, instance, owner=None)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "instance",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "owner",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __get__(self, instance, owner=None):\n    if instance is None:\n        return self\n    # get slice\n    return instance.arr[self.parent_field.slice].reshape(self.parent_field.shape)[\n        self.parent_slice\n    ]"
            },
            "__set__": {
              "name": "__set__",
              "path": "tatva.compound._field_sub_of_stack.__set__",
              "signature": "(self, instance, value) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "instance",
                  "annotation": "tatva.compound.Compound",
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": "jax.Array | float | int",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __set__(self, instance: Compound, value: Array | float | int) -> None:\n    arr = jnp.asarray(value)\n    instance.arr = (\n        instance.arr[self.parent_field.slice]\n        .reshape(self.parent_field.shape)\n        .at[self.parent_slice]\n        .set(arr)\n    ).flatten()"
            },
            "__getitem__": {
              "name": "__getitem__",
              "path": "tatva.compound._field_sub_of_stack.__getitem__",
              "signature": "(self, arg) -> Array",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "arg",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __getitem__(self, arg) -> Array:\n    # Normalize to tuple\n    if not isinstance(arg, tuple):\n        arg = (arg,)\n    # extend with full slices\n    if len(arg) < len(self.shape):\n        arg = arg + (slice(None),) * (len(self.shape) - len(arg))\n\n    # get indices in the parent field\n    parent_idxs = self.parent_field.__getitem__(slice(None)).reshape(\n        self.parent_field.shape\n    )\n    return parent_idxs[self.parent_slice].__getitem__(arg).flatten()"
            }
          },
          "source": "class _field_sub_of_stack(field):\n    \"\"\"A descriptor to define fields that are sub-fields of a stacked field in the State class.\"\"\"\n\n    def __init__(\n        self,\n        shape: tuple[int, ...],\n        parent_field: _field,\n        parent_slice: tuple[slice, ...],\n    ) -> None:\n        super().__init__(shape)\n        self.parent_field = parent_field\n        self.parent_slice = parent_slice\n\n    @overload\n    def __get__(self, instance: None, owner) -> field: ...\n    @overload\n    def __get__(self, instance: Compound, owner) -> Array: ...\n    def __get__(self, instance, owner=None):\n        if instance is None:\n            return self\n        # get slice\n        return instance.arr[self.parent_field.slice].reshape(self.parent_field.shape)[\n            self.parent_slice\n        ]\n\n    def __set__(self, instance: Compound, value: Array | float | int) -> None:\n        arr = jnp.asarray(value)\n        instance.arr = (\n            instance.arr[self.parent_field.slice]\n            .reshape(self.parent_field.shape)\n            .at[self.parent_slice]\n            .set(arr)\n        ).flatten()\n\n    def __getitem__(self, arg) -> Array:\n        # Normalize to tuple\n        if not isinstance(arg, tuple):\n            arg = (arg,)\n        # extend with full slices\n        if len(arg) < len(self.shape):\n            arg = arg + (slice(None),) * (len(self.shape) - len(arg))\n\n        # get indices in the parent field\n        parent_idxs = self.parent_field.__getitem__(slice(None)).reshape(\n            self.parent_field.shape\n        )\n        return parent_idxs[self.parent_slice].__getitem__(arg).flatten()",
          "inherited_members": {
            "tatva.compound._field": [
              {
                "kind": "attribute",
                "path": "tatva.compound._field.shape"
              },
              {
                "kind": "attribute",
                "path": "tatva.compound._field.default_factory"
              },
              {
                "kind": "attribute",
                "path": "tatva.compound._field.slice"
              }
            ],
            "tatva.compound.field": [
              {
                "kind": "function",
                "path": "tatva.compound.field.__delete__"
              }
            ]
          }
        },
        "_CompoundMeta": {
          "name": "_CompoundMeta",
          "path": "tatva.compound._CompoundMeta",
          "description": null,
          "parameters": [],
          "attributes": [
            {
              "name": "fields",
              "annotation": "tuple[tuple[str, tatva.compound.field], ...]",
              "description": null,
              "value": null
            },
            {
              "name": "size",
              "annotation": "int",
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__new__": {
              "name": "__new__",
              "path": "tatva.compound._CompoundMeta.__new__",
              "signature": "(mcls, name, bases, namespace, **kwargs)",
              "description": null,
              "parameters": [
                {
                  "name": "mcls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "bases",
                  "annotation": "tuple[type, ...]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "namespace",
                  "annotation": "dict[str, typing.Any]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __new__(\n    mcls, name: str, bases: tuple[type, ...], namespace: dict[str, Any], **kwargs\n):\n    fields: list[tuple[str, field]] = []\n    size: int = 0\n\n    # find all fields in the namespace and compute their slices in the flat array\n    for attr_name, attr_value in namespace.items():\n        if isinstance(attr_value, field):\n            n = int(jnp.prod(jnp.asarray(attr_value.shape)))\n            # get slice indices\n            start = size\n            end = start + n\n            attr_value.slice = slice(start, end)\n\n            fields.append((attr_name, attr_value))\n            size += n\n\n    cls = super().__new__(mcls, name, bases, namespace)\n    cls.fields = tuple(fields)\n    cls.size = size\n    if kwargs.get(\"stack_fields\") is not None:\n        cls._stack_fields(**kwargs)  # type: ignore\n\n    # register as pytree node for JAX transformations\n    register_pytree_node_class(cls)\n    return cls"
            },
            "__getitem__": {
              "name": "__getitem__",
              "path": "tatva.compound._CompoundMeta.__getitem__",
              "signature": "(cls, arg) -> Array",
              "description": null,
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "arg",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __getitem__(cls, arg) -> Array:\n    node, *dofs = arg if isinstance(arg, tuple) else (arg,)\n    nodal_vals = jnp.hstack(\n        [f[node].reshape(-1, *f.shape[1:]) for _, f in cls.fields],\n        dtype=int,\n    )\n    return (nodal_vals[:, *dofs] if dofs else nodal_vals).flatten()"
            }
          },
          "source": "class _CompoundMeta(type):\n    fields: tuple[tuple[str, field], ...]\n    size: int\n\n    def __new__(\n        mcls, name: str, bases: tuple[type, ...], namespace: dict[str, Any], **kwargs\n    ):\n        fields: list[tuple[str, field]] = []\n        size: int = 0\n\n        # find all fields in the namespace and compute their slices in the flat array\n        for attr_name, attr_value in namespace.items():\n            if isinstance(attr_value, field):\n                n = int(jnp.prod(jnp.asarray(attr_value.shape)))\n                # get slice indices\n                start = size\n                end = start + n\n                attr_value.slice = slice(start, end)\n\n                fields.append((attr_name, attr_value))\n                size += n\n\n        cls = super().__new__(mcls, name, bases, namespace)\n        cls.fields = tuple(fields)\n        cls.size = size\n        if kwargs.get(\"stack_fields\") is not None:\n            cls._stack_fields(**kwargs)  # type: ignore\n\n        # register as pytree node for JAX transformations\n        register_pytree_node_class(cls)\n        return cls\n\n    def __getitem__(cls, arg) -> Array:\n        node, *dofs = arg if isinstance(arg, tuple) else (arg,)\n        nodal_vals = jnp.hstack(\n            [f[node].reshape(-1, *f.shape[1:]) for _, f in cls.fields],\n            dtype=int,\n        )\n        return (nodal_vals[:, *dofs] if dofs else nodal_vals).flatten()",
          "inherited_members": {}
        },
        "Compound": {
          "name": "Compound",
          "path": "tatva.compound.Compound",
          "description": "A compound array/state.\n\nA helper class to create a compound state with multiple fields. It simplifies packing\nand unpacking into and from a flat array. Useful to manage fields while working with a\nflat array for the solver.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "arr",
              "annotation": "jax.Array | None",
              "description": [
                {
                  "kind": "text",
                  "value": "The flat data array. If None, initializes to zeros."
                }
              ],
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "arr",
              "annotation": "jax.Array",
              "description": null,
              "value": null
            },
            {
              "name": "size",
              "annotation": "int",
              "description": null,
              "value": "0"
            }
          ],
          "docstring": [
            {
              "kind": "text",
              "value": "Examples:\n\nCreate a compound state with fields::\n\n    class MyState(Compound):\n        u = field(shape=(N, 3))\n        phi = field(shape=(N,), default_factory=lambda: jnp.ones(N))\n\n    state = MyState()\n\nUse `state.arr` to access the flat array, and `state.u`, `state.phi` to access the\nindividual fields.\n\nYou can use iterator unpacking to directly unpack the fields from the state::\n\n    u, phi = MyState(arr)"
            }
          ],
          "functions": {
            "tree_flatten": {
              "name": "tree_flatten",
              "path": "tatva.compound.Compound.tree_flatten",
              "signature": "(self) -> tuple[tuple[Array], Any]",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def tree_flatten(self) -> tuple[tuple[Array], Any]:\n    return (self.arr,), None"
            },
            "tree_unflatten": {
              "name": "tree_unflatten",
              "path": "tatva.compound.Compound.tree_unflatten",
              "signature": "(cls, aux_data, children) -> Self",
              "description": null,
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "aux_data",
                  "annotation": "typing.Any",
                  "description": null,
                  "value": null
                },
                {
                  "name": "children",
                  "annotation": "tuple[jax.Array]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@classmethod\ndef tree_unflatten(cls, aux_data: Any, children: tuple[Array]) -> Self:\n    return cls(*children)"
            },
            "_stack_fields": {
              "name": "_stack_fields",
              "path": "tatva.compound.Compound._stack_fields",
              "signature": "(cls, stack_fields, stack_axis=-1) -> None",
              "description": "Reorder fields by stacking specified fields along some axis. Modifies the class\nin place!",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "stack_fields",
                  "annotation": "tuple[str, ...]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Names of the fields to be stacked."
                    }
                  ]
                },
                {
                  "name": "stack_axis",
                  "annotation": "int",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Axis along which to stack the fields. Defaults to -1."
                    }
                  ],
                  "value": "-1"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@classmethod\ndef _stack_fields(cls, stack_fields: tuple[str, ...], stack_axis: int = -1) -> None:\n    \"\"\"Reorder fields by stacking specified fields along some axis. Modifies the class\n    in place!\n\n    Args:\n        stack_fields: Names of the fields to be stacked.\n        stack_axis: Axis along which to stack the fields. Defaults to -1.\n    \"\"\"\n    fields = {k: v for k, v in cls.fields}\n    base_shape = fields[stack_fields[0]].shape\n    stack_axis = stack_axis % len(base_shape)  # get positive axis\n    base_shape = jnp.asarray(base_shape)[\n        jnp.array([i for i in range(len(base_shape)) if i != stack_axis])\n    ]\n\n    stack_size = sum(\n        int(jnp.prod(jnp.asarray(fields[name].shape))) // base_shape.prod()\n        for name in stack_fields\n    )\n    stacked_shape = jnp.insert(base_shape, stack_axis, stack_size)\n    size = int(jnp.prod(jnp.asarray(stacked_shape)))\n    stacked_slice = slice(0, size)\n    stacked_field = _field(tuple(stacked_shape), slice=stacked_slice)\n\n    new_fields = []\n\n    # create new fields that are sub-fields of the stacked field\n    for idx, name in enumerate(stack_fields):\n        new_field = _field_sub_of_stack(\n            shape=fields[name].shape,\n            parent_field=stacked_field,\n            parent_slice=tuple(\n                slice(None)\n                if i != stack_axis\n                else slice(\n                    sum(\n                        int(jnp.prod(jnp.asarray(fields[n].shape)))\n                        // base_shape.prod()\n                        for n in stack_fields[:idx]\n                    ),\n                    sum(\n                        int(jnp.prod(jnp.asarray(fields[n].shape)))\n                        // base_shape.prod()\n                        for n in stack_fields[: idx + 1]\n                    ),\n                )\n                for i in range(len(stacked_shape))\n            ),\n        )\n        # check base shape compatibility or raise error\n        if not jnp.all(\n            jnp.asarray(new_field.shape)[\n                jnp.array(\n                    [i for i in range(len(new_field.shape)) if i != stack_axis]\n                )\n            ]\n            == base_shape\n        ):\n            raise ValueError(\n                f\"Field {name} with shape {new_field.shape} is not compatible with \"\n                f\"base shape {base_shape} along axis {stack_axis}.\"\n            )\n\n        # set new field in class and add to new fields list\n        setattr(cls, name, new_field)\n        new_fields.append((name, new_field))\n\n    # update other fields slices\n    offset = size\n    for name, field_obj in cls.fields:\n        if name in stack_fields:\n            continue\n        n = int(jnp.prod(jnp.asarray(field_obj.shape)))\n        start = offset\n        end = start + n\n        field_obj.slice = slice(start, end)\n        offset += n\n        new_fields.append((name, field_obj))\n\n    # finally update class fields and size\n    cls.fields = tuple(new_fields)"
            },
            "__init__": {
              "name": "__init__",
              "path": "tatva.compound.Compound.__init__",
              "signature": "(self, arr=None) -> None",
              "description": "Initialize the state with given keyword arguments.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "arr",
                  "annotation": "jax.Array | None",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, arr: Array | None = None) -> None:\n    \"\"\"Initialize the state with given keyword arguments.\"\"\"\n    if arr is not None:\n        assert arr.size == self.size, (\n            f\"Array size {arr.size} does not match expected size {self.size}.\"\n        )\n        self.arr = arr\n    else:\n        self.arr = jnp.zeros(self.size, dtype=float)"
            },
            "__len__": {
              "name": "__len__",
              "path": "tatva.compound.Compound.__len__",
              "signature": "(self) -> int",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __len__(self) -> int:\n    return len(self.fields)"
            },
            "__iter__": {
              "name": "__iter__",
              "path": "tatva.compound.Compound.__iter__",
              "signature": "(self) -> Generator[Array, None, None]",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __iter__(self) -> Generator[Array, None, None]:\n    for name, _ in self.fields:\n        yield getattr(self, name)"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "tatva.compound.Compound.__repr__",
              "signature": "(self) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self) -> str:\n    # print shape of each field in the class\n    field_reprs = [\n        f\"{name}={getattr(type(self), name).shape}\" for name, _ in self.fields\n    ]\n    return f\"{self.__class__.__name__}({', '.join(field_reprs)})\""
            },
            "__add__": {
              "name": "__add__",
              "path": "tatva.compound.Compound.__add__",
              "signature": "(self, other) -> Self",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": "typing.Self",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __add__(self, other: Self) -> Self:\n    return self.__class__(self.arr + other.arr)"
            }
          },
          "source": "class Compound(metaclass=_CompoundMeta):\n    \"\"\"A compound array/state.\n\n    A helper class to create a compound state with multiple fields. It simplifies packing\n    and unpacking into and from a flat array. Useful to manage fields while working with a\n    flat array for the solver.\n\n    Args:\n        arr: The flat data array. If None, initializes to zeros.\n\n    Examples:\n\n    Create a compound state with fields::\n\n        class MyState(Compound):\n            u = field(shape=(N, 3))\n            phi = field(shape=(N,), default_factory=lambda: jnp.ones(N))\n\n        state = MyState()\n\n    Use `state.arr` to access the flat array, and `state.u`, `state.phi` to access the\n    individual fields.\n\n    You can use iterator unpacking to directly unpack the fields from the state::\n\n        u, phi = MyState(arr)\n\n    \"\"\"\n\n    arr: Array\n    size: int = 0\n\n    def tree_flatten(self) -> tuple[tuple[Array], Any]:\n        return (self.arr,), None\n\n    @classmethod\n    def tree_unflatten(cls, aux_data: Any, children: tuple[Array]) -> Self:\n        return cls(*children)\n\n    @classmethod\n    def _stack_fields(cls, stack_fields: tuple[str, ...], stack_axis: int = -1) -> None:\n        \"\"\"Reorder fields by stacking specified fields along some axis. Modifies the class\n        in place!\n\n        Args:\n            stack_fields: Names of the fields to be stacked.\n            stack_axis: Axis along which to stack the fields. Defaults to -1.\n        \"\"\"\n        fields = {k: v for k, v in cls.fields}\n        base_shape = fields[stack_fields[0]].shape\n        stack_axis = stack_axis % len(base_shape)  # get positive axis\n        base_shape = jnp.asarray(base_shape)[\n            jnp.array([i for i in range(len(base_shape)) if i != stack_axis])\n        ]\n\n        stack_size = sum(\n            int(jnp.prod(jnp.asarray(fields[name].shape))) // base_shape.prod()\n            for name in stack_fields\n        )\n        stacked_shape = jnp.insert(base_shape, stack_axis, stack_size)\n        size = int(jnp.prod(jnp.asarray(stacked_shape)))\n        stacked_slice = slice(0, size)\n        stacked_field = _field(tuple(stacked_shape), slice=stacked_slice)\n\n        new_fields = []\n\n        # create new fields that are sub-fields of the stacked field\n        for idx, name in enumerate(stack_fields):\n            new_field = _field_sub_of_stack(\n                shape=fields[name].shape,\n                parent_field=stacked_field,\n                parent_slice=tuple(\n                    slice(None)\n                    if i != stack_axis\n                    else slice(\n                        sum(\n                            int(jnp.prod(jnp.asarray(fields[n].shape)))\n                            // base_shape.prod()\n                            for n in stack_fields[:idx]\n                        ),\n                        sum(\n                            int(jnp.prod(jnp.asarray(fields[n].shape)))\n                            // base_shape.prod()\n                            for n in stack_fields[: idx + 1]\n                        ),\n                    )\n                    for i in range(len(stacked_shape))\n                ),\n            )\n            # check base shape compatibility or raise error\n            if not jnp.all(\n                jnp.asarray(new_field.shape)[\n                    jnp.array(\n                        [i for i in range(len(new_field.shape)) if i != stack_axis]\n                    )\n                ]\n                == base_shape\n            ):\n                raise ValueError(\n                    f\"Field {name} with shape {new_field.shape} is not compatible with \"\n                    f\"base shape {base_shape} along axis {stack_axis}.\"\n                )\n\n            # set new field in class and add to new fields list\n            setattr(cls, name, new_field)\n            new_fields.append((name, new_field))\n\n        # update other fields slices\n        offset = size\n        for name, field_obj in cls.fields:\n            if name in stack_fields:\n                continue\n            n = int(jnp.prod(jnp.asarray(field_obj.shape)))\n            start = offset\n            end = start + n\n            field_obj.slice = slice(start, end)\n            offset += n\n            new_fields.append((name, field_obj))\n\n        # finally update class fields and size\n        cls.fields = tuple(new_fields)\n\n    def __init__(self, arr: Array | None = None) -> None:\n        \"\"\"Initialize the state with given keyword arguments.\"\"\"\n        if arr is not None:\n            assert arr.size == self.size, (\n                f\"Array size {arr.size} does not match expected size {self.size}.\"\n            )\n            self.arr = arr\n        else:\n            self.arr = jnp.zeros(self.size, dtype=float)\n\n    def __len__(self) -> int:\n        return len(self.fields)\n\n    def __iter__(self) -> Generator[Array, None, None]:\n        for name, _ in self.fields:\n            yield getattr(self, name)\n\n    def __repr__(self) -> str:\n        # print shape of each field in the class\n        field_reprs = [\n            f\"{name}={getattr(type(self), name).shape}\" for name, _ in self.fields\n        ]\n        return f\"{self.__class__.__name__}({', '.join(field_reprs)})\"\n\n    def __add__(self, other: Self) -> Self:\n        return self.__class__(self.arr + other.arr)",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "mesh": {
      "name": "mesh",
      "path": "tatva.mesh",
      "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/mesh.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "ElementType": {
          "name": "ElementType",
          "path": "tatva.mesh.ElementType",
          "description": "Enumeration of different finite element types.",
          "parameters": [],
          "attributes": [
            {
              "name": "TRIANGLE",
              "annotation": null,
              "description": null,
              "value": "'triangle'"
            },
            {
              "name": "QUAD",
              "annotation": null,
              "description": null,
              "value": "'quad'"
            },
            {
              "name": "TETRAHEDRON",
              "annotation": null,
              "description": null,
              "value": "'tetrahedron'"
            },
            {
              "name": "HEXAHEDRON",
              "annotation": null,
              "description": null,
              "value": "'hexahedron'"
            }
          ],
          "docstring": [],
          "functions": {},
          "source": "class ElementType(Enum):\n    \"\"\"Enumeration of different finite element types.\"\"\"\n\n    TRIANGLE = \"triangle\"\n    QUAD = \"quad\"\n    TETRAHEDRON = \"tetrahedron\"\n    HEXAHEDRON = \"hexahedron\"",
          "inherited_members": {}
        },
        "Mesh": {
          "name": "Mesh",
          "path": "tatva.mesh.Mesh",
          "description": "A class used to represent a Mesh for finite element method (FEM) simulations.",
          "parameters": [],
          "attributes": [
            {
              "name": "coords",
              "annotation": "jax.jax.Array",
              "description": null,
              "value": null
            },
            {
              "name": "elements",
              "description": [
                {
                  "kind": "text",
                  "value": "The connectivity of the mesh elements."
                }
              ],
              "annotation": "jax.jax.Array",
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "unit_square": {
              "name": "unit_square",
              "path": "tatva.mesh.Mesh.unit_square",
              "signature": "(cls, n_x, n_y, *, type=ElementType.TRIANGLE, dim=2) -> Mesh",
              "description": "Generate a unit square mesh with n_x and n_y nodes in the x and y directions.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "n_x",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "n_y",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "type",
                  "annotation": "tatva.mesh.ElementType | typing.Literal['triangle', 'quad']",
                  "description": null,
                  "value": "tatva.mesh.ElementType.tatva.mesh.ElementType.TRIANGLE"
                },
                {
                  "name": "dim",
                  "annotation": "typing.Literal[2, 3]",
                  "description": null,
                  "value": "2"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@classmethod\ndef unit_square(\n    cls,\n    n_x: int,\n    n_y: int,\n    *,\n    type: ElementType | Literal[\"triangle\", \"quad\"] = ElementType.TRIANGLE,\n    dim: Literal[2, 3] = 2,\n) -> Mesh:\n    \"\"\"Generate a unit square mesh with n_x and n_y nodes in the x and y directions.\"\"\"\n    return cls.rectangle((0.0, 1.0), (0.0, 1.0), n_x, n_y, type=type, dim=dim)"
            },
            "rectangle": {
              "name": "rectangle",
              "path": "tatva.mesh.Mesh.rectangle",
              "signature": "(cls, x, y, n_x, n_y, *, type=ElementType.TRIANGLE, dim=2) -> Mesh",
              "description": "Generate a rectangular mesh with specified x and y ranges and number of nodes.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "x",
                  "annotation": "tuple[float, float]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "tuple[float, float]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "n_x",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "n_y",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "type",
                  "annotation": "tatva.mesh.ElementType | typing.Literal['triangle', 'quad']",
                  "description": null,
                  "value": "tatva.mesh.ElementType.tatva.mesh.ElementType.TRIANGLE"
                },
                {
                  "name": "dim",
                  "annotation": "typing.Literal[2, 3]",
                  "description": null,
                  "value": "2"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@classmethod\ndef rectangle(\n    cls,\n    x: tuple[float, float],\n    y: tuple[float, float],\n    n_x: int,\n    n_y: int,\n    *,\n    type: ElementType | Literal[\"triangle\", \"quad\"] = ElementType.TRIANGLE,\n    dim: Literal[2, 3] = 2,\n) -> Mesh:\n    \"\"\"Generate a rectangular mesh with specified x and y ranges and number of nodes.\"\"\"\n    match ElementType(type):\n        case ElementType.TRIANGLE:\n            coords, elements = cls._rectangle_triangular(x, y, n_x, n_y, dim)\n        case ElementType.QUAD:\n            coords, elements = cls._rectangle_quadrilateral(x, y, n_x, n_y, dim)\n        case _:\n            raise NotImplementedError(f\"Element type {type} not implemented.\")\n\n    return cls(coords=coords, elements=elements)"
            },
            "_rectangle_triangular": {
              "name": "_rectangle_triangular",
              "path": "tatva.mesh.Mesh._rectangle_triangular",
              "signature": "(x, y, n_x, n_y, dim=2) -> tuple[jax.Array, jax.Array]",
              "description": null,
              "parameters": [
                {
                  "name": "x",
                  "annotation": "tuple[float, float]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "tuple[float, float]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "n_x",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "n_y",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "dim",
                  "annotation": "int",
                  "description": null,
                  "value": "2"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef _rectangle_triangular(\n    x: tuple[float, float], y: tuple[float, float], n_x: int, n_y: int, dim: int = 2\n) -> tuple[jax.Array, jax.Array]:\n    x_vals = jnp.linspace(x[0], x[1], n_x + 1)\n    y_vals = jnp.linspace(y[0], y[1], n_y + 1)\n    xv, yv = jnp.meshgrid(x_vals, y_vals, indexing=\"ij\")\n    coords = jnp.stack([xv.ravel(), yv.ravel()], axis=-1)\n\n    def node_id(i, j):\n        return i * (n_y + 1) + j\n\n    elements = []\n    for i in range(n_x):\n        for j in range(n_y):\n            n0 = node_id(i, j)\n            n1 = node_id(i + 1, j)\n            n2 = node_id(i, j + 1)\n            n3 = node_id(i + 1, j + 1)\n            elements.append([n0, n1, n3])\n            elements.append([n0, n3, n2])\n\n    if dim == 3:\n        coords = jnp.hstack([coords, jnp.zeros((coords.shape[0], 1))])\n\n    return coords, jnp.array(elements, dtype=jnp.int32)"
            },
            "_rectangle_quadrilateral": {
              "name": "_rectangle_quadrilateral",
              "path": "tatva.mesh.Mesh._rectangle_quadrilateral",
              "signature": "(x, y, n_x, n_y, dim=2) -> tuple[jax.Array, jax.Array]",
              "description": null,
              "parameters": [
                {
                  "name": "x",
                  "annotation": "tuple[float, float]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "y",
                  "annotation": "tuple[float, float]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "n_x",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "n_y",
                  "annotation": "int",
                  "description": null,
                  "value": null
                },
                {
                  "name": "dim",
                  "annotation": "int",
                  "description": null,
                  "value": "2"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@staticmethod\ndef _rectangle_quadrilateral(\n    x: tuple[float, float], y: tuple[float, float], n_x: int, n_y: int, dim: int = 2\n) -> tuple[jax.Array, jax.Array]:\n    x_vals = jnp.linspace(x[0], x[1], n_x + 1)\n    y_vals = jnp.linspace(y[0], y[1], n_y + 1)\n    xv, yv = jnp.meshgrid(x_vals, y_vals, indexing=\"ij\")\n    coords = jnp.stack([xv.ravel(), yv.ravel()], axis=-1)\n\n    def node_id(i, j):\n        return i * (n_y + 1) + j\n\n    elements = []\n    for i in range(n_x):\n        for j in range(n_y):\n            n0 = node_id(i, j)\n            n1 = node_id(i + 1, j)\n            n2 = node_id(i + 1, j + 1)\n            n3 = node_id(i, j + 1)\n            elements.append([n0, n1, n2, n3])\n\n    if dim == 3:\n        coords = jnp.hstack([coords, jnp.zeros((coords.shape[0], 1))])\n\n    return coords, jnp.array(elements, dtype=jnp.int32)"
            }
          },
          "source": "class Mesh(NamedTuple):\n    \"\"\"A class used to represent a Mesh for finite element method (FEM) simulations.\n\n    Attributes:\n        nodes: The coordinates of the mesh nodes.\n        elements: The connectivity of the mesh elements.\n    \"\"\"\n\n    coords: jax.Array  # Shape (n_nodes, n_dim)\n    elements: jax.Array  # Shape (n_elements, n_nodes_per_element)\n\n    @classmethod\n    def unit_square(\n        cls,\n        n_x: int,\n        n_y: int,\n        *,\n        type: ElementType | Literal[\"triangle\", \"quad\"] = ElementType.TRIANGLE,\n        dim: Literal[2, 3] = 2,\n    ) -> Mesh:\n        \"\"\"Generate a unit square mesh with n_x and n_y nodes in the x and y directions.\"\"\"\n        return cls.rectangle((0.0, 1.0), (0.0, 1.0), n_x, n_y, type=type, dim=dim)\n\n    @classmethod\n    def rectangle(\n        cls,\n        x: tuple[float, float],\n        y: tuple[float, float],\n        n_x: int,\n        n_y: int,\n        *,\n        type: ElementType | Literal[\"triangle\", \"quad\"] = ElementType.TRIANGLE,\n        dim: Literal[2, 3] = 2,\n    ) -> Mesh:\n        \"\"\"Generate a rectangular mesh with specified x and y ranges and number of nodes.\"\"\"\n        match ElementType(type):\n            case ElementType.TRIANGLE:\n                coords, elements = cls._rectangle_triangular(x, y, n_x, n_y, dim)\n            case ElementType.QUAD:\n                coords, elements = cls._rectangle_quadrilateral(x, y, n_x, n_y, dim)\n            case _:\n                raise NotImplementedError(f\"Element type {type} not implemented.\")\n\n        return cls(coords=coords, elements=elements)\n\n    @staticmethod\n    def _rectangle_triangular(\n        x: tuple[float, float], y: tuple[float, float], n_x: int, n_y: int, dim: int = 2\n    ) -> tuple[jax.Array, jax.Array]:\n        x_vals = jnp.linspace(x[0], x[1], n_x + 1)\n        y_vals = jnp.linspace(y[0], y[1], n_y + 1)\n        xv, yv = jnp.meshgrid(x_vals, y_vals, indexing=\"ij\")\n        coords = jnp.stack([xv.ravel(), yv.ravel()], axis=-1)\n\n        def node_id(i, j):\n            return i * (n_y + 1) + j\n\n        elements = []\n        for i in range(n_x):\n            for j in range(n_y):\n                n0 = node_id(i, j)\n                n1 = node_id(i + 1, j)\n                n2 = node_id(i, j + 1)\n                n3 = node_id(i + 1, j + 1)\n                elements.append([n0, n1, n3])\n                elements.append([n0, n3, n2])\n\n        if dim == 3:\n            coords = jnp.hstack([coords, jnp.zeros((coords.shape[0], 1))])\n\n        return coords, jnp.array(elements, dtype=jnp.int32)\n\n    @staticmethod\n    def _rectangle_quadrilateral(\n        x: tuple[float, float], y: tuple[float, float], n_x: int, n_y: int, dim: int = 2\n    ) -> tuple[jax.Array, jax.Array]:\n        x_vals = jnp.linspace(x[0], x[1], n_x + 1)\n        y_vals = jnp.linspace(y[0], y[1], n_y + 1)\n        xv, yv = jnp.meshgrid(x_vals, y_vals, indexing=\"ij\")\n        coords = jnp.stack([xv.ravel(), yv.ravel()], axis=-1)\n\n        def node_id(i, j):\n            return i * (n_y + 1) + j\n\n        elements = []\n        for i in range(n_x):\n            for j in range(n_y):\n                n0 = node_id(i, j)\n                n1 = node_id(i + 1, j)\n                n2 = node_id(i + 1, j + 1)\n                n3 = node_id(i, j + 1)\n                elements.append([n0, n1, n2, n3])\n\n        if dim == 3:\n            coords = jnp.hstack([coords, jnp.zeros((coords.shape[0], 1))])\n\n        return coords, jnp.array(elements, dtype=jnp.int32)",
          "inherited_members": {}
        }
      },
      "functions": {
        "find_containing_polygons": {
          "name": "find_containing_polygons",
          "path": "tatva.mesh.find_containing_polygons",
          "signature": "(points, polygons) -> jax.Array",
          "description": "Finds the index of the containing polygon for each point.\n\nThis function uses a vectorized Ray Casting algorithm and is JIT-compiled\nfor maximum performance. It assumes polygons are non-overlapping.",
          "parameters": [
            {
              "name": "points",
              "annotation": "Array",
              "description": [
                {
                  "kind": "text",
                  "value": "An array of points to test, shape (num_points, 2)."
                }
              ]
            },
            {
              "name": "polygons",
              "annotation": "Array",
              "description": [
                {
                  "kind": "text",
                  "value": "A 3D array of polygons, where each polygon is a list of\nvertices. Shape (num_polygons, num_vertices, 2)."
                }
              ]
            }
          ],
          "returns": {
            "name": "Array",
            "annotation": "jax.jax.Array",
            "description": "An array of shape (num_points,) where each element is the index of the\npolygon containing the corresponding point. Returns -1 if a point is not in\nany polygon."
          },
          "docstring": [],
          "source": "@jax.jit\ndef find_containing_polygons(\n    points: jax.Array,\n    polygons: jax.Array,\n) -> jax.Array:\n    \"\"\"\n    Finds the index of the containing polygon for each point.\n\n    This function uses a vectorized Ray Casting algorithm and is JIT-compiled\n    for maximum performance. It assumes polygons are non-overlapping.\n\n    Args:\n        points (Array): An array of points to test, shape (num_points, 2).\n        polygons (Array): A 3D array of polygons, where each polygon is a list of\n            vertices. Shape (num_polygons, num_vertices, 2).\n\n    Returns:\n        Array: An array of shape (num_points,) where each element is the index of the\n            polygon containing the corresponding point. Returns -1 if a point is not in\n            any polygon.\n    \"\"\"\n\n    # --- Core function for a single point and a single polygon ---\n    def is_inside(point, vertices):\n        px, py = point\n\n        # Get all edges of the polygon by pairing vertices with the next one\n        p1s = vertices\n        p2s = jnp.roll(vertices, -1, axis=0)  # Get p_{i+1} for each p_i\n\n        # Conditions for a valid intersection of the horizontal ray from the point\n        # 1. The point's y-coord must be between the edge's y-endpoints\n        y_cond = (p1s[:, 1] <= py) & (p2s[:, 1] > py) | (p2s[:, 1] <= py) & (\n            p1s[:, 1] > py\n        )\n\n        # 2. The point's x-coord must be to the left of the edge's x-intersection\n        # Calculate the x-intersection of the ray with the edge\n        x_intersect = (p2s[:, 0] - p1s[:, 0]) * (py - p1s[:, 1]) / (\n            p2s[:, 1] - p1s[:, 1]\n        ) + p1s[:, 0]\n        x_cond = px < x_intersect\n\n        # An intersection occurs if both conditions are met.\n        intersections = jnp.sum(y_cond & x_cond)\n\n        # The point is inside if the number of intersections is odd.\n        return intersections % 2 == 1\n\n    # --- Vectorize and apply the function ---\n    # Create a boolean matrix: matrix[i, j] is True if point i is in polygon j\n    # Vmap over points (axis 0) and polygons (axis 0)\n    # in_axes=(0, None) -> maps over points, polygon is fixed\n    # in_axes=(None, 0) -> maps over polygons, point is fixed\n    # We vmap the second case over all points\n    is_inside_matrix = jax.vmap(\n        lambda p: jax.vmap(lambda poly: is_inside(p, poly))(polygons), in_axes=(0)\n    )(points)\n\n    # Find the index of the first 'True' value for each point (row).\n    # This gives the index of the containing polygon.\n    # We add a 'False' column to handle points outside all polygons.\n    # jnp.argmax will then return the index of this last column.\n\n    padded_matrix = jnp.pad(\n        is_inside_matrix, ((0, 0), (0, 1)), \"constant\", constant_values=False\n    )\n\n    # If the point is not in any polygon, the all values in the row will be False.\n    # We use this to map the index to -1.\n    not_in_any_polygon = jnp.all(~is_inside_matrix, axis=1)\n\n    indices = jnp.argmax(padded_matrix, axis=1)\n\n    # we map the index to -1 if the point is not in any polygon.\n    return jnp.where(not_in_any_polygon == True, -1, indices)"
        }
      }
    },
    "plotting": {
      "name": "plotting",
      "path": "tatva.plotting",
      "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/plotting/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "_pyvista": {
          "name": "_pyvista",
          "path": "tatva.plotting._pyvista",
          "filepath": "/home/florez/work/code/tatva-fork/docs/.venv/lib/python3.14/site-packages/tatva/plotting/_pyvista.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {},
          "functions": {
            "get_pyvista_grid": {
              "name": "get_pyvista_grid",
              "path": "tatva.plotting._pyvista.get_pyvista_grid",
              "signature": "(mesh, cell_type='quad')",
              "description": null,
              "parameters": [
                {
                  "name": "mesh",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "cell_type",
                  "annotation": null,
                  "description": null,
                  "value": "'quad'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def get_pyvista_grid(mesh, cell_type=\"quad\"):\n    if mesh.coords.shape[1] == 2:\n        pv_points = np.hstack((mesh.coords, np.zeros(shape=(mesh.coords.shape[0], 1))))\n    else:\n        pv_points = mesh.coords\n\n    cell_type_dict = {\n        \"quad\": 4,\n        \"triangle\": 3,\n        \"tetra\": 4,\n    }\n\n    pv_cells = np.hstack(\n        (\n            np.full(\n                fill_value=cell_type_dict[cell_type], shape=(mesh.elements.shape[0], 1)\n            ),\n            mesh.elements,\n        )\n    )\n\n    pv_cell_type_dict = {\n        \"quad\": pv.CellType.QUAD,\n        \"triangle\": pv.CellType.TRIANGLE,\n        \"tetra\": pv.CellType.TETRA,\n    }\n    cell_types = np.full(\n        fill_value=pv_cell_type_dict[cell_type], shape=(mesh.elements.shape[0],)\n    )\n\n    grid = pv.UnstructuredGrid(pv_cells, cell_types, pv_points)\n\n    return grid"
            }
          }
        }
      },
      "classes": {},
      "functions": {
        "plot_element_values": {
          "name": "plot_element_values",
          "path": "tatva.plotting.plot_element_values",
          "signature": "(coords, elements, values, *, u=None, ax=None, scale=1.0, label=None, cmap='managua_r', **kwargs)",
          "description": "Plot the element values of a field on a mesh.",
          "parameters": [
            {
              "name": "coords",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "The coordinates of the mesh nodes."
                }
              ]
            },
            {
              "name": "elements",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "The connectivity of the mesh elements."
                }
              ]
            },
            {
              "name": "values",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "The element values to plot."
                }
              ]
            },
            {
              "name": "u",
              "annotation": "typing.Optional[jax.Array]",
              "description": [
                {
                  "kind": "text",
                  "value": "The displacement field."
                }
              ],
              "value": "None"
            },
            {
              "name": "ax",
              "annotation": "typing.Optional[matplotlib.axes.Axes]",
              "description": [
                {
                  "kind": "text",
                  "value": "The axes to plot on."
                }
              ],
              "value": "None"
            },
            {
              "name": "scale",
              "annotation": "float",
              "description": [
                {
                  "kind": "text",
                  "value": "The scale of the displacement field."
                }
              ],
              "value": "1.0"
            },
            {
              "name": "label",
              "annotation": "typing.Optional[str]",
              "description": [
                {
                  "kind": "text",
                  "value": "The label of the colorbar."
                }
              ],
              "value": "None"
            },
            {
              "name": "cmap",
              "annotation": null,
              "description": [
                {
                  "kind": "text",
                  "value": "The colormap to use."
                }
              ],
              "value": "'managua_r'"
            },
            {
              "name": "kwargs",
              "annotation": null,
              "description": null,
              "value": "{}"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def plot_element_values(\n    coords: Array,\n    elements: Array,\n    values: Array,\n    *,\n    u: Optional[Array] = None,\n    ax: Optional[Axes] = None,\n    scale: float = 1.0,\n    label: Optional[str] = None,\n    cmap=\"managua_r\",\n    **kwargs,\n):\n    \"\"\"\n    Plot the element values of a field on a mesh.\n\n    Args:\n        coords: The coordinates of the mesh nodes.\n        elements: The connectivity of the mesh elements.\n        values: The element values to plot.\n        u: The displacement field.\n        ax: The axes to plot on.\n        scale: The scale of the displacement field.\n        label: The label of the colorbar.\n        cmap: The colormap to use.\n        **kwargs : Additional keyword arguments to pass to PolyCollection.\n    \"\"\"\n\n    if u is not None:\n        coords = coords + scale * u\n\n    vertices = coords[elements]\n\n    if ax is None:\n        fig = plt.figure(figsize=(5, 4))\n        ax = fig.add_subplot(111)\n\n    poly = PolyCollection(vertices, cmap=cmap, linewidths=0.3, **kwargs)  # pyright: ignore[reportArgumentType]\n    poly.set_array(values.flatten())\n    poly.set_edgecolor(\"face\")\n    ax.add_collection(poly)\n\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\n    plt.colorbar(poly, cax=cax, label=label, orientation=\"horizontal\", location=\"top\")"
        },
        "plot_nodal_values": {
          "name": "plot_nodal_values",
          "path": "tatva.plotting.plot_nodal_values",
          "signature": "(coords, elements, values, *, u=None, ax=None, scale=1.0, label=None, cmap='managua_r', edgecolors='none', shading='gouraud', **kwargs)",
          "description": "Plot the nodal values of a field on a mesh.",
          "parameters": [
            {
              "name": "coords",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "The coordinates of the mesh nodes."
                }
              ]
            },
            {
              "name": "elements",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "The connectivity of the mesh elements."
                }
              ]
            },
            {
              "name": "values",
              "annotation": "jax.Array",
              "description": [
                {
                  "kind": "text",
                  "value": "The element values to plot."
                }
              ]
            },
            {
              "name": "u",
              "annotation": "typing.Optional[jax.Array]",
              "description": [
                {
                  "kind": "text",
                  "value": "The displacement field."
                }
              ],
              "value": "None"
            },
            {
              "name": "ax",
              "annotation": "typing.Optional[matplotlib.axes.Axes]",
              "description": [
                {
                  "kind": "text",
                  "value": "The axes to plot on."
                }
              ],
              "value": "None"
            },
            {
              "name": "scale",
              "annotation": "float",
              "description": [
                {
                  "kind": "text",
                  "value": "The scale of the displacement field."
                }
              ],
              "value": "1.0"
            },
            {
              "name": "label",
              "annotation": "typing.Optional[str]",
              "description": [
                {
                  "kind": "text",
                  "value": "The label of the colorbar."
                }
              ],
              "value": "None"
            },
            {
              "name": "cmap",
              "annotation": null,
              "description": [
                {
                  "kind": "text",
                  "value": "The colormap to use."
                }
              ],
              "value": "'managua_r'"
            },
            {
              "name": "edgecolors",
              "annotation": "str",
              "description": [
                {
                  "kind": "text",
                  "value": "The edge colors of the triangles."
                }
              ],
              "value": "'none'"
            },
            {
              "name": "shading",
              "annotation": "typing.Literal['flat', 'gouraud']",
              "description": [
                {
                  "kind": "text",
                  "value": "The shading of the triangles."
                }
              ],
              "value": "'gouraud'"
            },
            {
              "name": "kwargs",
              "annotation": null,
              "description": null,
              "value": "{}"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def plot_nodal_values(\n    coords: Array,\n    elements: Array,\n    values: Array,\n    *,\n    u: Optional[Array] = None,\n    ax: Optional[Axes] = None,\n    scale: float = 1.0,\n    label: Optional[str] = None,\n    cmap=\"managua_r\",\n    edgecolors: str = \"none\",\n    shading: Literal[\"flat\", \"gouraud\"] = \"gouraud\",\n    **kwargs,\n):\n    \"\"\"\n    Plot the nodal values of a field on a mesh.\n\n    Args:\n        coords: The coordinates of the mesh nodes.\n        elements: The connectivity of the mesh elements.\n        values: The element values to plot.\n        u: The displacement field.\n        ax: The axes to plot on.\n        scale: The scale of the displacement field.\n        label: The label of the colorbar.\n        cmap: The colormap to use.\n        edgecolors: The edge colors of the triangles.\n        shading: The shading of the triangles.\n        **kwargs: Additional keyword arguments to pass to tripcolor.\n    \"\"\"\n\n    coords_np = np.asarray(coords)\n    if u is not None:\n        coords_np = coords_np + scale * np.asarray(u)\n\n    if ax is None:\n        fig = plt.figure(figsize=(5, 4))\n        ax = fig.add_subplot(111)\n\n    elements_np = np.asarray(elements)\n\n    if elements_np.shape[1] == 3:\n        triangles = elements_np\n    elif elements_np.shape[1] == 4:\n        # Split each quad into two triangles along the (0, 2) diagonal.\n        first_half = elements_np[:, [0, 1, 2]]\n        second_half = elements_np[:, [0, 2, 3]]\n        triangles = np.concatenate((first_half, second_half), axis=0)\n    else:\n        raise ValueError(\n            \"Only triangular or quadrilateral elements are supported for nodal values.\"\n        )\n\n    triangles = np.asarray(triangles, dtype=int)\n    tri = Triangulation(coords_np[:, 0], coords_np[:, 1], triangles)\n\n    cb = ax.tripcolor(\n        tri,\n        np.asarray(values),\n        shading=shading,\n        cmap=cmap,\n        edgecolors=edgecolors,\n        **kwargs,\n    )\n\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes(\"top\", size=\"10%\", pad=0.2)\n    plt.colorbar(cb, cax=cax, label=label, orientation=\"horizontal\", location=\"top\")"
        }
      }
    }
  },
  "classes": {},
  "functions": {},
  "version": "0.3.1"
}